# Занятие 8. Интерфейсы и перечисления

## Интерфейсы

_Интерфейс_ — это спецификация (контракт) поведения объектов класса.
*Интерфейс* — это ссылочный тип данных, который представляет собой набор абстрактных методов (до Java 8) и глобальных констант. 

Класс реализует абстрактные методы одного или нескольких интерфейсов, тем самым обеспечивается описанное интерфейсом поведение объектов этого класса.

Интерфейс объявляется с помощью ключевого слова `interface`. Интерфейс содержит абстрактные методы (ключевое слово `abstract` указывать необязательно).
```java
public interface MyInterface {
    // Абстрактные методы (неявно public abstract)
    void doSomething();
    void doSomethingOther();
}
```

Интерфейс может включать публичные статические завершенные переменные (глобальные константы). При этом ключевые слова `public`, `static`, и `final` в объявлении таких констант необязательно.

```java
public interface MyInterface {
    // Константы (неявно public static final)
    int MY_CONST = 0; String MY_ANOTHER_CONST = "Hello World!";
    
    // Абстрактные методы (неявно public abstract)
    void doSomething();
    void doSomethingMore();
}
```

Интерфейс может быть реализован в классе. Объявление класса включает ключевое слово `implements`, после которого через запятую перечисляются имена реализуемых интерфейсов. Все абстрактные методы, объявленные в этих интерфейсах, должны быть переопределены в классе.

```java
public class MyClass implements MyInterface {
    // Реализации абстрактных методов
    public void doSomething() {
        // Инструкции
    }
    
    public void doSomethingOther() {
        // Другие инструкции
    }
    
    // Возможно еще поля, методы и конструкторы
}
```

### Пример с графическими фигурами

Рассмотрим иерархию классов, объекты которых представляют графические фигуры, и интерфейсов, определяющих некоторое поведение этих объектов.

Определим три интерфейса, определяющих некоторое поведение графических фигур.

Интерфейс, определяющий поведение площадных графических фигур.
```java
public interface Area {
    // Абстрактный метод (неявно public abstract)
    // Вычислить площадь фигуры
    int area();
}
```

Интерфейс, определяющий поведение масштабируемых графических фигур.
```java
public interface Scalable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение множителя масштабирования
    float MIN_FACTOR = 0.01F, MAX_FACTOR = 100.0F; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Масштабировать фигуру по ширине и высоте пропорционально
    void scale(float factor);
    // Масштабировать фигуру по ширине и высоте раздельно
    void scale(float wFactor, float hFactor);
}
```

Интерфейс, определяющий поведение вращающихся графических фигур.
```java
public interface Rotatable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение угла поворота
    int MIN_ANGLE = -360, MAX_ANGLE = 360; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Повернуть фигуру на заданный угол
    void rotate(int angle);
}
```

Например, есть абстрактный класс, который определяет любую графическую фигуру.
Поскольку еще неизвестно является ли некоторая графическая фигура площадной, может ли она масштабироваться или вращаться, то данный класс пока не реализует никаких интерфейсов.

```java
import java.awt.*;

// Абстрактный класс графических фигур
public abstract class Shape {
    // Цвет фигуры
    private Color color;

    // Методы доступа к закрытым полям
    
    // Конструкторы

    // Абстрактный метод для рисования фигур 
    public abstract void draw(Graphics2D g);
}
```

Например, объекты класса, представляющие прямоугольники, являются площадными, масштабируются и вращаются.  Поэтому их класс реализует интерфейсы Area, Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих прямоугольники,
// реализует интерфейсы Area, Scalable, Rotatable
public class Rectangle extends Shape implements Area, Scalable, Rotatable {
    // Нестатические поля, задающие состояние объектов типа Rectangle
    // Координаты левого верхнего угла органичивающей рамки фигуры
    private int x, y;   
    // Ширина и высота
    private int width, height;
    // Угол поворота
    private int angle;
    
    // Методы доступа к закрытым полям
    
    // Конструкторы

    // Переопределение абстрактных методов, 
    // унаследованных от интерфейса Scalable    
    public int area() {
        return width * height;
    }
    
    // Переопределение абстрактных методов, 
    // унаследованных от интерфейса Scalable    
    public void scale(float factor) {
        scale(factor, factor);
    }
    
    public void scale(float wFactor, float hFactor) {
        // Проверка допустимости значения с помощью констант Scalable
        if (wFactor >= MIN_FACTOR && wFactor<= MAX_FACTOR)
            setWidth(Math.round(width * wFactor));
        
        // Проверка допустимости значения с помощью констант Scalable
        if (hFactor>= MIN_FACTOR && hFactor<= MAX_FACTOR)
            setHeight(Math.round(height * hFactor));
    }

    // Переопределение абстрактного метода, 
    // унаследованного от интерфейса Rotatable    
    public void rotate(int angle) {
        // Проверка допустимости значения с помощью констант Rotatable
        if (angle >= MIN_ANGLE && angle <= MAX_ANGLE)
            setAngle(angle);
    }

    // Переопределение абстрактного метода, 
    // унаследованного от суперкласса Shape    
    public void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

Например, объекты класса, представляющие точки, не являются площадными, не масштабируются и не вращаются.  Поэтому их класс не реализует интерфейсы Area, Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих точки,
// не реализует никаких интерфейсов
public class Point extends Shape {
    // Координаты точки
    private int x, y;
    
    // Методы доступа к закрытым полям 
        
    // Конструкторы

    // Переопределение абстрактных методов
    public abstract void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

Например, объекты класса, представляющие линии, не являются площадными, но могут масштабироваться и вращаться.  Поэтому их класс не реализует интерфейс Area, но реализует интерфейсы Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих линии,
// реализует только интерфейсы Scalable, Rotatable
public class Line extends Shape implements Scalable, Rotatable {
    // Координаты линии задаются двумя точками
    private x1, y1, x2, y2;
    
    // Методы доступа к закрытым полям
        
    // Конструкторы

    // Переопределение абстрактных методов
    public abstract void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

### Методы по умолчанию

*Метод по умолчанию* — это метод в интерфейсе, который имеет свою реализацию (тело), а не только объявление. Ключевое слово `default` используется для его обозначения.

> До Java 8: Интерфейсы могли содержать только абстрактные методы (без реализации). Это создавало большую проблему при эволюции API: если нужно было добавить новый метод в существующий интерфейс, все классы, реализующие этот интерфейс, должны были бы быть переписаны, чтобы предоставить реализацию для нового метода. 
> 
> С появлением методов по умолчанию можно добавлять новую функциональность в интерфейсы, не ломая при этом существующий код.

```java
public interface MyInterface {
    
    // Обычный абстрактный метод (не имеет реализации)
    void abstractMethod();
    
    // Метод по умолчанию (имеет реализацию)
    default void defaultMethod() {
        // Реализация метода
        System.out.println("Это реализация метода по умолчанию.");
        privateMethod(); // Можно вызывать приватные методы
    }
    
    // Статический метод в интерфейсе (тоже появился в Java 8)
    static void staticMethod() {
        System.out.println("Это статический метод в интерфейсе.");
    }
    
    // Приватный метод (появился в Java 9, помогает устранить дублирование кода в default методах)
    private void privateMethod() {
        System.out.println("Внутренняя логика.");
    }
}
```

### Наследование интерфейсов

Интерфейсы могут наследоваться от других интерфейсов с помощью ключевого слова `extends`. В отличие от классов, интерфейс может наследоваться от нескольких интерфейсов одновременно.

```java
// Первый базовый интерфейс
interface A {
    void methodA();
}

// Второй базовый интерфейс
interface B {
    void methodB();
}

// Производный интерфейс, унаследованный от двух базовых интерфейсов
interface C extends A, B {
    void methodC();
}
```

Класс, реализующий производный интерфейс, должен реализовать все абстрактные методы, включая унаследованные от базовых интерфейсов.

```java
interface C extends A, B {
    void methodA() { 
        // реализация метода, объявленного в базовом интерфейсе A
    } 
    void methodB() { 
        // реализация метода, объявленного в базовом интерфейсе B
    } 
    void methodC() { 
        // реализация метода, объявленного в производном интерфейсе С
    } 
}
```

### Вложенные интерфейсы

Вложенные интерфейсы — это интерфейсы, объявленные внутри другого класса или интерфейса. Они используются для логической группировки связанных компонентов и улучшения инкапсуляции.

Интерфейс внутри класса:
```java
public class OuterClass {
    // Вложенный интерфейс
    public interface NestedInterface {
        void nestedMethod();
    }
    
    // Реализация вложенного интерфейса внутри того же класса
    public class NestedInterfaceImpl implements NestedInterface {
        @Override
        public void nestedMethod() {
            System.out.println("Реализация вложенного интерфейса");
        }
    }
}
```

Интерфейс внутри интерфейса:
```java
public interface OuterInterface {
    void outerMethod();
    
    // Вложенный интерфейс
    interface NestedInterface {
        void nestedMethod();
    }
}
```

Использование вложенных интерфейсов из вне:
```java
// Реализация вложенного интерфейса вне внешнего класса
public class ExternalImplementation implements OuterClass.NestedInterface {
    @Override
    public void nestedMethod() {
        System.out.println("Внешняя реализация вложенного интерфейса");
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        OuterClass.NestedInterface impl = new ExternalImplementation();
        impl.nestedMethod();
    }
}
```

## Перечисления

_Перечисления_ — это специальный тип данных для представления набора предопределенных константных значений.

Перечисление объявляется с помощью ключевого слова `enum`.

```java
// Дни недели
public enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```

Перечисленные константы являются публичными и статическими.
```java
public class Main {
    public static void main(String[] args) {
        Day today = Day.MONDAY;
        
        if (today == Day.SATURDAY || today == Day.SUNDAY) {
            System.out.println("Выходной!");
        } else {
            System.out.println("Рабочий день");
        }
        
        // Перебор всех значений
        for (Day day : Day.values()) {
            System.out.println(day);
        }
    }
}
```

### Перечисление с методами и конструкторами

Перечисление может включать поля, конструкторы и методы.
Создадим перечисление для представления цветовой палитры.

```java
// Цвета заданной палитры
public enum ColorPalette {
    RED("красный"),
    GREEN("зеленый"),
    BLUE("синий"),
    YELLOW("желтый"),
    BLACK("черный");
    
    // Поле
    private final String russianName;
    
    // Конструктор
    ColorPalette(String russianName) {
        this.russianName = russianName;
    }
    
    // Методы
    public String getRussianName() {
        return russianName;
    }
    
    public boolean isCold() {
        return this == BLUE || this == GREEN;
    }

    public boolean isWarm() {
        return this == RED || this == YELLOW;
    }
}
```

Создадим перечисление для представления цветов заданной палитры с расширенной функциональностью.

```java
public enum ColorPalette {
    // Основные цвета
    RED(255, 0, 0),
    GREEN(0, 255, 0),
    BLUE(0, 0, 255),
    
    // Дополнительные цвета
    YELLOW(255, 255, 0),
    ORANGE(255, 165, 0),
    PURPLE(128, 0, 128),
    PINK(255, 192, 203),
    BROWN(165, 42, 42),
    
    // Специальные цвета
    CYAN(0, 255, 255),
    MAGENTA(255, 0, 255),
    GOLD(255, 215, 0),
    SILVER(192, 192, 192);
    
    private final int red;
    private final int green;
    private final int blue;
    
    // Конструктор
    ColorPalette(int red, int green, int blue) {
        this.red = red;
        this.green = green;
        this.blue = blue;
    }
    
    // Геттеры для компонентов цвета
    public int getRed() {
        return red;
    }
    
    public int getGreen() {
        return green;
    }
    
    public int getBlue() {
        return blue;
    }
      
    // Метод для создания объекта типа Color 
    public Color toColor() {
        return new Color(red, green, blue);
    }
    
    // Метод для проверки является ли цвет светлым
    public boolean isLight() {
        // Простая формула для определения яркости
        double brightness = (red * 0.299 + green * 0.587 + blue * 0.114) / 255;
        return brightness > 0.5;
    }
    
    // Статический метод для получения случайного цвета
    public static ColorPalette getRandom() {
        ColorPalette[] colors = values();
        int randomIndex = (int)(Math.random() * colors.length);
        return colors[randomIndex];
    }
    
    // Метод для поиска цвета по названию (без учета регистра)
    public static ColorPalette findByName(String name) {
        for (ColorPalette color : values()) {
            if (color.name().equalsIgnoreCase(name)) {
                return color;
            }
        }
        return null;
    }
}
```

Рассмотрим использование данного перечисления при работе с графическими фигурами. 
```java
// Абстрактный суперкласс графических фигур 
public abstract class Shape {    
    // Здесь перечисление ColorPalette используется 
    // как тип данных при объявлении поля сolor
    protected ColorPalette сolor;
    
    public Shape(ColorPalette color) {
        this.color = color;
    }
    
    public abstract void draw(Graphics2D g);
    
    // Геттеры и сеттеры
    public ColorPalette getColor() {
        return color;
    }
    
    public void setColor(ColorPalette color) {
        this.color = color;
    }
}

// Подкласс прямоугольников
public class Rectangle extends Shape {  
    public Rectangle(ColorPalette color) {
        super(color);
    }
    // Поля, методы и констуркторы
}

// Подкласс эллипсов
public class Ellipse extends Shape {
    public Ellipse(ColorPalette color) {
        super(color);
    }
    // Поля, методы и констуркторы
}

// Подкласс треугольников
public class Triangle extends Shape {
    public Triangle(ColorPalette color) {
        super(color);
    }
    // Поля, методы и констуркторы
}
```

Все объекты типа данных, определенного перечислением, доступны как публичные статические константы через имя перечисления.
```java
// Пример использования констант перечисления ColorPalette
public class Main {
    public static void main(String[] args) {
        // Создание фигур с цветами из палитры
        Shape rect = new Rectangle(ColorPalette.GOLD);
        Shape ellipse = new Ellipse(ColorPalette.SILVER);
        
        // Случайный цвет
        Shape randomShape = new Triangle(ColorPalette.getRandom());
        
        // Рисование фигур
    }
}
```

### Вложенные перечисления

Перечисления могут быть вложенными в классы.
```java
// Абстрактный суперкласс графических фигур 
public abstract class Shape {    
    // Здесь перечисление ColorPalette используется 
    // как тип данных при объявлении поля сolor
    protected ColorPalette сolor;
    
    // Поля, методы и констуркторы

    // Вложенное перечисление в статическом контексте
    public static enum ColorPalette {
        // Ахроматические цвета
        BLACK(0, 0, 0),
        WHITE(255, 255, 255),
        GRAY(128, 128, 128),
        LIGHT_GRAY(211, 211, 211),
        DARK_GRAY(169, 169, 169),
    
        private final int red;
        private final int green;
        private final int blue;
    
        // Конструктор
        ColorPalette(int red, int green, int blue) {
            this.red = red;
            this.green = green;
            this.blue = blue;
        }
    }
}
```

Такие вложенные перечисления, доступны через имя внешнего класса.
```java
// Пример использования констант перечисления ColorPalette
public class Main {
    public static void main(String[] args) {
        // Создание фигур с цветами из палитры
        Shape rect = new Rectangle(Shape.ColorPalette.LIGHT_GRAY);
        Shape ellipse = new Ellipse(Shape.ColorPalette.DARK_GRAY);
      
        // Рисование фигур
    }
}
```

## Задания

**8-1** — 1 балл

- Разработать абстрактный класс «Shape» для представления графических фигур с абстрактным метод рисования на графическом контексте.

- Разработать интерфейс «Scalable», определяющий поведения масштабируемых графических фигур: в интерфейсе должны быть определены абстрактные методы масштабирования, глобальные константы, определяющие минимальное и максимальное значение коэффициента масштабирования.  

- Разработать класс «Rectangle», унаследованный от класса «Shape», для представления прямоугольников: класс должен реализовывать абстрактные методы интерфейса «Scalable». Переопределенные методы интерфейса «Scalable» должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения коэффициента масштабирования.

**8-2** — 1 балл

- Разработать интерфейс «Rotatable», определяющий поведения поворачиваемых графических фигур: в интерфейсе должны быть определены абстрактные методы поворота фигуры на заданный угол, глобальные константы, определяющие минимальное и максимальное значение угла поворота.

- Разработать класс «Ellipse», унаследованный от класса «Shape», для представления эллипсов: класс должен реализовывать абстрактные методов интерфейсов «Scalable» и «Rotatable». Переопределенные методы интерфейса «Scalable» должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения Переопределенные методы интерфейса «Scalable» должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения коэффициента масштабирования. Переопределенные методы интерфейса «Rotatable» должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения угла поворота.

- Дополнить класс «Rectangle» статическим методом создания вписанного эллипса.
Дополнить класс «Ellipse» статическим методом создания охватывающего прямоугольника.

- Разработать программу позволяющую создавать и рисовать (в графическом файле) прямоугольники и эллипсы с возможностью их масштабирования и поворота.

- Создать серию изображений одного массива графических фигур с поворотами на 0&deg;, 45&deg;, 90&deg; и масштабами 50%, 100%, 200%.

**8-3** — 2 балла



## Вопросы

1.	
2.	Где вы объявили интерфейсы в вашем коде?
3.	Выделите тело какого-либо интерфейса в вашем коде?
4.	Переопределение методов
5.	Интерфейсы
6.	Расширение интерфейсов
7.	Реализация интерфейсов
8.	Принципы ООП: Полиморфизм
9.	Приведение ссылочных типов данных
10.	Статические поля и методы

## Ресурсы


