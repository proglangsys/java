# Занятие 8. Интерфейсы и перечисления

## Интерфейсы

_Интерфейс_ — это спецификация (контракт) поведения объектов класса.
*Интерфейс* — это ссылочный тип данных, который представляет собой набор абстрактных методов (до Java 8) и глобальных констант. 

Класс реализует абстрактные методы одного или нескольких интерфейсов, тем самым обеспечивается описанное интерфейсом поведение объектов этого класса.

Интерфейс объявляется с помощью ключевого слова `interface`. Интерфейс содержит абстрактные методы (ключевое слово `abstract` указывать необязательно).
```java
public interface MyInterface {
    // Абстрактные методы (неявно public abstract)
    void doSomething();
    void doSomethingOther();
}
```

Интерфейс может включать публичные статические завершенные переменные (глобальные константы). При этом ключевые слова `public`, `static`, и `final` в объявлении таких констант необязательно.

```java
public interface MyInterface {
    // Константы (неявно public static final)
    int MY_CONST = 0; String MY_ANOTHER_CONST = "Hello World!";
    
    // Абстрактные методы (неявно public abstract)
    void doSomething();
    void doSomethingMore();
}
```

Интерфейс может быть реализован в классе. Объявление класса включает ключевое слово `implements`, после которого через запятую перечисляются имена реализуемых интерфейсов. Все абстрактные методы, объявленные в этих интерфейсах, должны быть переопределены в классе.

```java
public class MyClass implements MyInterface {
    // Реализации абстрактных методов
    public void doSomething() {
        // Инструкции
    }
    
    public void doSomethingOther() {
        // Другие инструкции
    }
    
    // Возможно еще поля, методы и конструкторы
}
```

### Пример с графическими фигурами

Рассмотрим иерархию классов, объекты которых представляют графические фигуры, и интерфейсов, определяющих некоторое поведение этих объектов.

Определим три интерфейса, определяющих некоторое поведение графических фигур.

Интерфейс, определяющий поведение площадных графических фигур.
```java
public interface Area {
    // Абстрактный метод (неявно public abstract)
    // Вычислить площадь фигуры
    int area();
}
```

Интерфейс, определяющий поведение масштабируемых графических фигур.
```java
public interface Scalable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение множителя масштабирования
    float MIN_FACTOR = 0.01F, MAX_FACTOR = 100.0F; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Масштабировать фигуру по ширине и высоте пропорционально
    void scale(float factor);
    // Масштабировать фигуру по ширине и высоте раздельно
    void scale(float wFactor, float hFactor);
}
```

Интерфейс, определяющий поведение вращающихся графических фигур.
```java
public interface Rotatable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение угла поворота
    int MIN_ANGLE = -360, MAX_ANGLE = 360; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Повернуть фигуру на заданный угол
    void rotate(int angle);
}
```

Например, есть абстрактный класс, который определяет любую графическую фигуру.
Поскольку еще неизвестно является ли некоторая графическая фигура площадной, может ли она масштабироваться или вращаться, то данный класс пока не реализует никаких интерфейсов.

```java
import java.awt.*;

// Абстрактный класс графических фигур
public abstract class Shape {
    // Цвет фигуры
    private Color color;

    // Методы доступа к закрытым полям
    
    // Конструкторы

    // Абстрактный метод для рисования фигур 
    public abstract void draw(Graphics2D g);
}
```

Например, объекты класса, представляющие прямоугольники, являются площадными, масштабируются и вращаются.  Поэтому их класс реализует интерфейсы Area, Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих прямоугольники,
// реализует интерфейсы Area, Scalable, Rotatable
public class Rectangle extends Shape implements Area, Scalable, Rotatable {
    // Нестатические поля, задающие состояние объектов типа Rectangle
    // Координаты левого верхнего угла органичивающей рамки фигуры
    private int x, y;   
    // Ширина и высота
    private int width, height;
    // Угол поворота
    private int angle;
    
    // Методы доступа к закрытым полям
    
    // Конструкторы

    // Переопределение абстрактных методов, 
    // унаследованных от интерфейса Scalable    
    public int area() {
        return width * height;
    }
    
    // Переопределение абстрактных методов, 
    // унаследованных от интерфейса Scalable    
    public void scale(float factor) {
        scale(factor, factor);
    }
    
    public void scale(float wFactor, float hFactor) {
        // Проверка допустимости значения с помощью констант Scalable
        if (wFactor >= MIN_FACTOR && wFactor<= MAX_FACTOR)
            setWidth(Math.round(width * wFactor));
        
        // Проверка допустимости значения с помощью констант Scalable
        if (hFactor>= MIN_FACTOR && hFactor<= MAX_FACTOR)
            setHeight(Math.round(height * hFactor));
    }

    // Переопределение абстрактного метода, 
    // унаследованного от интерфейса Rotatable    
    public void rotate(int angle) {
        // Проверка допустимости значения с помощью констант Rotatable
        if (angle >= MIN_ANGLE && angle <= MAX_ANGLE)
            setAngle(angle);
    }

    // Переопределение абстрактного метода, 
    // унаследованного от суперкласса Shape    
    public void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

Например, объекты класса, представляющие точки, не являются площадными, не масштабируются и не вращаются.  Поэтому их класс не реализует интерфейсы Area, Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих точки,
// не реализует никаких интерфейсов
public class Point extends Shape {
    // Координаты точки
    private int x, y;
    
    // Методы доступа к закрытым полям 
        
    // Конструкторы

    // Переопределение абстрактных методов
    public abstract void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

Например, объекты класса, представляющие линии, не являются площадными, но могут масштабироваться и вращаться.  Поэтому их класс не реализует интерфейс Area, но реализует интерфейсы Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих линии,
// реализует только интерфейсы Scalable, Rotatable
public class Line extends Shape implements Scalable, Rotatable {
    // Координаты линии задаются двумя точками
    private x1, y1, x2, y2;
    
    // Методы доступа к закрытым полям
        
    // Конструкторы

    // Переопределение абстрактных методов
    public abstract void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

### Методы по умолчанию

*Метод по умолчанию* — это метод в интерфейсе, который имеет свою реализацию (тело), а не только объявление. Ключевое слово `default` используется для его обозначения.

> До Java 8: Интерфейсы могли содержать только абстрактные методы (без реализации). Это создавало большую проблему при эволюции API: если нужно было добавить новый метод в существующий интерфейс, все классы, реализующие этот интерфейс, должны были бы быть переписаны, чтобы предоставить реализацию для нового метода. 
> 
> С появлением методов по умолчанию можно добавлять новую функциональность в интерфейсы, не ломая при этом существующий код.

```java
public interface MyInterface {
    
    // Обычный абстрактный метод (не имеет реализации)
    void abstractMethod();
    
    // Метод по умолчанию (имеет реализацию)
    default void defaultMethod() {
        // Реализация метода
        System.out.println("Это реализация метода по умолчанию.");
        privateMethod(); // Можно вызывать приватные методы
    }
    
    // Статический метод в интерфейсе (тоже появился в Java 8)
    static void staticMethod() {
        System.out.println("Это статический метод в интерфейсе.");
    }
    
    // Приватный метод (появился в Java 9, помогает устранить дублирование кода в default методах)
    private void privateMethod() {
        System.out.println("Внутренняя логика.");
    }
}
```

### Наследование интерфейсов

Интерфейсы могут наследоваться от других интерфейсов с помощью ключевого слова `extends`. В отличие от классов, интерфейс может наследоваться от нескольких интерфейсов одновременно.

```java
// Первый базовый интерфейс
interface A {
    void methodA();
}

// Второй базовый интерфейс
interface B {
    void methodB();
}

// Производный интерфейс, унаследованный от двух базовых интерфейсов
interface C extends A, B {
    void methodC();
}
```

Класс, реализующий производный интерфейс, должен реализовать все абстрактные методы, включая унаследованные от базовых интерфейсов.

```java
interface C extends A, B {
    void methodA() { 
        // реализация метода, объявленного в базовом интерфейсе A
    } 
    void methodB() { 
        // реализация метода, объявленного в базовом интерфейсе B
    } 
    void methodC() { 
        // реализация метода, объявленного в производном интерфейсе С
    } 
}
```

### Вложенные интерфейсы

Вложенные интерфейсы — это интерфейсы, объявленные внутри другого класса или интерфейса. Они используются для логической группировки связанных компонентов и улучшения инкапсуляции.

Интерфейс внутри класса:
```java
public class OuterClass {
    // Вложенный интерфейс
    public interface NestedInterface {
        void nestedMethod();
    }
    
    // Реализация вложенного интерфейса внутри того же класса
    public class NestedInterfaceImpl implements NestedInterface {
        @Override
        public void nestedMethod() {
            System.out.println("Реализация вложенного интерфейса");
        }
    }
}
```

Интерфейс внутри интерфейса:
```java
public interface OuterInterface {
    void outerMethod();
    
    // Вложенный интерфейс
    interface NestedInterface {
        void nestedMethod();
    }
}
```

Использование вложенных интерфейсов из вне:
```java
// Реализация вложенного интерфейса вне внешнего класса
public class ExternalImplementation implements OuterClass.NestedInterface {
    @Override
    public void nestedMethod() {
        System.out.println("Внешняя реализация вложенного интерфейса");
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        OuterClass.NestedInterface impl = new ExternalImplementation();
        impl.nestedMethod();
    }
}
```

## Перечисления

_Перечисления_ — это специальный тип данных для представления набора предопределенных константных значений.

Перечисление объявляется с помощью ключевого слова `enum`.

```java
// Дни недели
public enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```

Перечисленные константы являются публичными и статическими.
```java
public class Main {
    public static void main(String[] args) {
        Day today = Day.MONDAY;
        
        if (today == Day.SATURDAY || today == Day.SUNDAY) {
            System.out.println("Выходной!");
        } else {
            System.out.println("Рабочий день");
        }
        
        // Перебор всех значений
        for (Day day : Day.values()) {
            System.out.println(day);
        }
    }
}
```

### Перечисление с методами и конструкторами

Перечисление может включать поля, конструкторы и методы.
Создадим перечисление для представления цветовой палитры.

```java
// Цвета заданной палитры
public enum ColorPalette {
    RED("красный"),
    GREEN("зеленый"),
    BLUE("синий"),
    YELLOW("желтый"),
    BLACK("черный");
    
    // Поле
    private final String russianName;
    
    // Конструктор
    ColorPalette(String russianName) {
        this.russianName = russianName;
    }
    
    // Методы
    public String getRussianName() {
        return russianName;
    }
    
    public boolean isCold() {
        return this == BLUE || this == GREEN;
    }

    public boolean isWarm() {
        return this == RED || this == YELLOW;
    }
}
```

Создадим перечисление для представления цветов заданной палитры с расширенной функциональностью.

```java
public enum ColorPalette {
    // Основные цвета
    RED(255, 0, 0),
    GREEN(0, 255, 0),
    BLUE(0, 0, 255),
    
    // Дополнительные цвета
    YELLOW(255, 255, 0),
    ORANGE(255, 165, 0),
    PURPLE(128, 0, 128),
    PINK(255, 192, 203),
    BROWN(165, 42, 42),
    
    // Специальные цвета
    CYAN(0, 255, 255),
    MAGENTA(255, 0, 255),
    GOLD(255, 215, 0),
    SILVER(192, 192, 192);
    
    private final int red;
    private final int green;
    private final int blue;
    
    // Конструктор
    ColorPalette(int red, int green, int blue) {
        this.red = red;
        this.green = green;
        this.blue = blue;
    }
    
    // Геттеры для компонентов цвета
    public int getRed() {
        return red;
    }
    
    public int getGreen() {
        return green;
    }
    
    public int getBlue() {
        return blue;
    }
      
    // Метод для создания объекта типа Color 
    public Color toColor() {
        return new Color(red, green, blue);
    }
    
    // Метод для проверки является ли цвет светлым
    public boolean isLight() {
        // Простая формула для определения яркости
        double brightness = (red * 0.299 + green * 0.587 + blue * 0.114) / 255;
        return brightness > 0.5;
    }
    
    // Статический метод для получения случайного цвета
    public static ColorPalette getRandom() {
        ColorPalette[] colors = values();
        int randomIndex = (int)(Math.random() * colors.length);
        return colors[randomIndex];
    }
    
    // Метод для поиска цвета по названию (без учета регистра)
    public static ColorPalette findByName(String name) {
        for (ColorPalette color : values()) {
            if (color.name().equalsIgnoreCase(name)) {
                return color;
            }
        }
        return null;
    }
}
```

Рассмотрим использование данного перечисления при работе с графическими фигурами. 
```java
// Абстрактный суперкласс графических фигур 
public abstract class Shape {    
    // Здесь перечисление ColorPalette используется 
    // как тип данных при объявлении поля сolor
    protected ColorPalette сolor;
    
    public Shape(ColorPalette color) {
        this.color = color;
    }
    
    public abstract void draw(Graphics2D g);
    
    // Геттеры и сеттеры
    public ColorPalette getColor() {
        return color;
    }
    
    public void setColor(ColorPalette color) {
        this.color = color;
    }
}

// Подкласс прямоугольников
public class Rectangle extends Shape {  
    public Rectangle(ColorPalette color) {
        super(color);
    }
    // Поля, методы и констуркторы
}

// Подкласс эллипсов
public class Ellipse extends Shape {
    public Ellipse(ColorPalette color) {
        super(color);
    }
    // Поля, методы и констуркторы
}

// Подкласс треугольников
public class Triangle extends Shape {
    public Triangle(ColorPalette color) {
        super(color);
    }
    // Поля, методы и констуркторы
}
```

Все объекты типа данных, определенного перечислением, доступны как публичные статические константы через имя перечисления.
```java
// Пример использования констант перечисления ColorPalette
public class Main {
    public static void main(String[] args) {
        // Создание фигур с цветами из палитры
        Shape rect = new Rectangle(ColorPalette.GOLD);
        Shape ellipse = new Ellipse(ColorPalette.SILVER);
        
        // Случайный цвет
        Shape randomShape = new Triangle(ColorPalette.getRandom());
        
        // Рисование фигур
    }
}
```

### Вложенные перечисления

Перечисления могут быть вложенными в классы.
```java
// Абстрактный суперкласс графических фигур 
public abstract class Shape {    
    // Здесь перечисление ColorPalette используется 
    // как тип данных при объявлении поля сolor
    protected ColorPalette сolor;
    
    // Поля, методы и констуркторы

    // Вложенное перечисление в статическом контексте
    public static enum ColorPalette {
        // Ахроматические цвета
        BLACK(0, 0, 0),
        WHITE(255, 255, 255),
        GRAY(128, 128, 128),
        LIGHT_GRAY(211, 211, 211),
        DARK_GRAY(169, 169, 169),
    
        private final int red;
        private final int green;
        private final int blue;
    
        // Конструктор
        ColorPalette(int red, int green, int blue) {
            this.red = red;
            this.green = green;
            this.blue = blue;
        }
    }
}
```

Такие вложенные перечисления, доступны через имя внешнего класса.
```java
// Пример использования констант перечисления ColorPalette
public class Main {
    public static void main(String[] args) {
        // Создание фигур с цветами из палитры
        Shape rect = new Rectangle(Shape.ColorPalette.LIGHT_GRAY);
        Shape ellipse = new Ellipse(Shape.ColorPalette.DARK_GRAY);
      
        // Рисование фигур
    }
}
```

## Задания

**8-1** — 1 балл
- Разработать интерфейс `Drawable` определяющий поведение графических фигур, отрисовываемых на графическом контексте: в интерфейсе должен быть определен абстрактный метод рисования на графическом контексте.
- Разработать интерфейс `Movable`, определяющий поведение перемещаемых графических фигур: в интерфейсе должны быть определены абстрактные методы перемещения.  
- Разработать интерфейс `Scalable`, определяющий поведение масштабируемых графических фигур: в интерфейсе должны быть определены абстрактные методы масштабирования, глобальные константы, определяющие минимальное и максимальное значение коэффициента масштабирования.  
- Разработать интерфейс `Rotatable`, определяющий поведения поворачиваемых графических фигур: в интерфейсе должны быть определены абстрактные методы поворота фигуры на заданный угол, глобальные константы, определяющие минимальное и максимальное значение угла поворота.
- Разработать интерфейс `Transformable`, определяющий поведение трансформируемых (поворачиваемых и масштабируемых) графических фигур. 
Интерфейс `Transformable` должен быть унаследован от интерфейсов `Scalable` и `Rotatable`.
- Разработать интерфейс `AreaCalculable`, определяющий поведение площадных графических фигур: в интерфейсе должны быть определены абстрактные методы вычисления площади графической фигуры.  
- Разработать класс `Rectangle` для представления прямоугольников: класс должен реализовывать абстрактные методы интерфейсов `Drawable`, `Transformable` и `AreaCalculable`.
- Разработать класс `Ellipse` для представления эллипсов: класс должен реализовывать абстрактные методов интерфейсов `Drawable`, `Movable`, `Transformable` и `AreaCalculable`.
- Переопределенные методы интерфейсов `Scalable` должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения коэффициента масштабирования.
- Переопределенные методы интерфейса `Rotatable` должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения угла поворота.
- Поля, определяющие состояние объектов разработанных классов графических фигур должны быть закрытыми. Для доступа к таким полям должны быть реализованы аксессоры.
- В классах графических фигур должны быть реализованы конструкторы.
- Интерфейсы и классы должны быть размещены в пакете `ru.isu.math.graphics`.
- Разработать отдельный Main-класс в пакете  `ru.isu.math.demo`  с main-методом, в котором необходимо создать несколько объектов классов  `Rectangle` и `Ellipse`  с помощью доступных конструкторов и через доступное поведение (перемещение, поворот, масштабирование) объектов класса  `Rectangle`  и `Ellipse` изменить их состояние. Вычислить площади созданных прямоугольников и эллипсов.  `Rectangle` и `Ellipse` изменить их состояние. Вычислить площади созданных прямоугольников и эллипсов повторно.
- Продемонстрировать работу отладчика в IDE. Установить точку останова в вашем коде. Запустить отладчик. Показать какие значения имеют локальные переменные в момент останова. Сделать один или несколько шагов так, продемонстрировать изменение значений локальных переменных при пошаговом выполнении кода. Установить курсор в некоторой строке вашего кода и выполнить код до этой строки; показать какие значения имеют локальные переменные в этот момент. Возобновить выполнение программы в обычном режиме.

**8-2** — 1 балл
- Разработать класс `Point` для представления точек: класс должен реализовывать абстрактные методы интерфейсов `Drawable` и `Movable`.
- Разработать класс `Line` для представления линий: класс должен реализовывать абстрактные методов интерфейсов `Drawable`, `Movable`, `Scalable` и `Rotatable`. 
- Разработать класс `Triangle` для представления треугольников: класс должен реализовывать абстрактные методов интерфейсов `Drawable`, `Movable`, `Scalable`, `Rotatable` и `AreaCalculable`. 
- Переопределенные методы интерфейсов `Scalable` должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения коэффициента масштабирования.
- Переопределенные методы интерфейса `Rotatable` должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения угла поворота.
- Поля, определяющие состояние объектов разработанных классов графических фигур должны быть закрытыми. Для доступа к таким полям должны быть реализованы аксессоры.
- В классах графических фигур должны быть реализованы конструкторы.
- Интерфейсы и классы должны быть размещены в пакете `ru.isu.math.graphics`.
- Разработать перечисление `ColorPalette` для представления константных цветов заданной палитры.
- Дополнить все классы графических фигур нестатическими полями, задающими цвет заливки с помощью констант перечисления `ColorPalette`.
- Разработать отдельный Main-класс в пакете  `ru.isu.math.demo`  с main-методом, в котором необходимо создать несколько объектов классов  `Point`, `Line`, `Rectangle`, `Ellipse` и `Triangle` с цветами заливки, заданными константами перечисления `ColorPalette`. Добавить все созданные объекты в массив типа  `Drawable[]`. Добавить все трансформируемые фигуры в массив типа  `Transformable[]`. Перебрав данный массив, повернуть все фигуры на 45 градусов и увеличить их размеры в 1.5 раза. Добавить площадные фигуры в массив типа  `AreaCalculable[]`. Перебрав данный массив, вычислить суммарную площадь всех фигур. 

**8-3** — 2 балла

- Разработать приложение с интерфейсом командной строки (CLI) для создания и управления простыми графическими фигурами (прямоугольники, эллипсы, треугольники) с возможностью экспорта результата в растровое изображение. 
- Дополнить классы `Point`, `Line`, `Rectangle`, `Ellipse` и  `Triangle` СТРОИТЕЛЯМИ для пошагового создания их объектов.
- Программа должна поддерживать ПОШАГОВОЕ создание всех типов фигур: точки, линии, прямоугольники, эллипсы и треугольники с помощью СТРОИТЕЛЕЙ. (Фигуры должны быть представлены объектами соответственно классов `Point`, `Line`, `Rectangle`, `Ellipse` и  `Triangle`, описанных в двух предыдущих заданиях.)
- Программа должна позволять перемещать выбранной фигуры на заданное смещение по осям X и Y.
- Программа должна позволять вращать выбранную фигуру на заданный угол в градусах.
- Программа должна позволять увеличивать или уменьшать размер существующей фигуры в заданное количество раз.
- Программа должна сохранять все созданные фигуры в файл изображения в формате PNG.
- Сопроводить исходный код Javadoc-комментариями и сгенерировать HTML-документацию с помощью команды javadoc.
- Собрать проект в виде запускаемого JAR-файла и продемонстрировать его работу.

Поддерживаемые команды:
- Создание фигур
	-   `create rectangle <x> <y> <width> <height> <color>`
	-   `create ellipse <x> <y> <width> <height> <color>`
	- 	`create rectangle <x> <y> <side> <color>`
	-   `create ellipse <x> <y> <side> <color>`
	-   Пример: `create rectangle 50 50 100 #FF0000` — создает прямоугольник с вершиной в (50, 50), шириной 100 и высотой 100, заполненный красным цветом.
	- После создания фигура получает уникальный числовой идентификатор (ID). Этот ID используется для управления фигурой в последующих командах.
- Перемещение фигур
	-   `move <id> <dx> <dy>`
	-   Пример: `move 1 10 -5` — перемещает фигуру с ID=1 на 10 пикселей вправо и на 5 пикселей вверх.
- Вращение фигур
	-   `rotate <id> <angle>`
	-   Пример: `rotate 1 90` — вращает фигуру с ID=1 на 90 градусов.
- Масштабирование фигур
	-   `scale <id> <factor>`
	-   Пример: `scale 1 1.5` — увеличивает фигуру с ID=1 в 1.5 раза.
	-   Пример: `scale 2 0.5` — уменьшает фигуру с ID=2 в 2 раза.
- Экспорт в изображение
	-   `export <filename.png>`
	-   Пример: `export my_drawing.png` — сохраняет изображение в файл `my_drawing.png` в текущей директории.
- Прочие команды
	-   `list` — выводит в консоль список всех фигур с их ID, типами и параметрами.
	-   `exit` — завершает работу приложения.

## Вопросы

1.	Где вы объявили интерфейсы в вашем коде?
2.	Объясните объявление какого-либо интерфейса в вашем коде?
3.	Выделите тело какого-либо интерфейса в вашем коде?
4.	Какие абстрактные методы объявлены в вашем интерфейсе?
5.	Есть ли методы по умолчанию в вашем интерфейсе?
6.	Какой уровень доступа имеет тот или иной метод в вашем интерфейсе?
7.	Объясните сигнатуру того или иного метода в вашем интерфейсе?
8.	Какой возвращаемый тип данных имеет тот или иной метод в вашем интерфейсе?
9.	Какие абстрактные методы реализованы в вашем коде?
10. Покажите методы, которые реализуют абстрактные методы?
11.  Есть ли в вашем коде методы, которые переопределяют другие методы?
12. Какие статические завершенные переменные есть в вашем коде?
13. Какие публичные константы есть в вашем коде?
14. Есть ли методы без реализации в вашем коде?
15.	Есть ли статические методы в вашем интерфейсе?
16. Есть ли закрытые методы в вашем интерфейсе?
17. Есть в вашем коде одиночное наследование интерфейсов?
18.  Есть в вашем коде множественное наследование интерфейсов?
19.  Какие классы реализуют тот или иной интерфейс в вашем коде?
20.	Используете ли вы расширение интерфейсов?
21.	Объясните: как вы используете полиморфизм в вашем коде?
22.	Используете ли вы приведение ссылочных типов данных?
23.	Какой вид приведения ссылочных типов данных вы используете: сужение или расширение?
24.	Есть ли перечисление в вашем коде?
25.	Какие константные значения есть в вашем перечислении?
26.	Какие конструкторы есть в вашем перечислении?
27.	Какие методы есть в вашем перечислении?
28.	Как вы используете константные значения вашего перечисления?
29.	Является ли созданные вами интерфейсы вложенными или верхнего уровня?
30.	Является ли созданное вами перечисление вложенным или верхнего уровня? 

## Ресурсы


