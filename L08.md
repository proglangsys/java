# Занятие 7. Интерфейсы

## Интерфейсы

_Интерфейс_ — это спецификация (контракт) поведения объектов класса.
*Интерфейс* — это ссылочный тип данных, который представляет собой набор абстрактных методов (до Java 8) и глобальных констант. 

Класс реализует абстрактные методы одного или нескольких интерфейсов, тем самым обеспечивается описанное интерфейсом поведение объектов этого класса.

Интерфейс объявляется с помощью ключевого слова `interface`. Интерфейс содержит абстрактные методы (ключевое слово `abstract` указывать необязательно).
```java
public interface MyInterface {
    // Абстрактные методы (неявно public abstract)
    void doSomething();
    void doSomethingOther();
}
```

Интерфейс может включать публичные статические завершенные переменные (глобальные константы). При этом ключевые слова `public`, `static`, и `final` в объявлении таких констант необязательно.

```java
public interface MyInterface {
    // Константы (неявно public static final)
    int MY_CONST = 0; String MY_ANOTHER_CONST = "Hello World!";
    
    // Абстрактные методы (неявно public abstract)
    void doSomething();
    void doSomethingMore();
}
```

Интерфейс может быть реализован в классе. Объявление класса включает ключевое слово `implements`, после которого через запятую перечисляются имена реализуемых интерфейсов. Все абстрактные методы, объявленные в этих интерфейсах, должны быть переопределены в классе.

```java
public class MyClass implements MyInterface {
    // Реализации абстрактных методов
    public void doSomething() {
        // Инструкции
    }
    
    public void doSomethingOther() {
        // Другие инструкции
    }
    
    // Возможно еще поля, методы и конструкторы
}
```

### Пример с графическими фигурами

Рассмотрим иерархию классов, объекты которых представляют графические фигуры, и интерфейсов, определяющих некоторое поведение этих объектов.

Определим три интерфейса, определяющих некоторое поведение графических фигур.

Интерфейс, определяющий поведение площадных графических фигур.
```java
public interface Area {
    // Абстрактный метод (неявно public abstract)
    // Вычислить площадь фигуры
    int area();
}
```

Интерфейс, определяющий поведение масштабируемых графических фигур.
```java
public interface Scalable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение множителя масштабирования
    float MIN_FACTOR = 0.01F, MAX_FACTOR = 100.0F; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Масштабировать фигуру по ширине и высоте пропорционально
    void scale(float factor);
    // Масштабировать фигуру по ширине и высоте раздельно
    void scale(float wFactor, float hFactor);
}
```

Интерфейс, определяющий поведение вращающихся графических фигур.
```java
public interface Rotatable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение угла поворота
    int MIN_ANGLE = -360, MAX_ANGLE = 360; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Повернуть фигуру на заданный угол
    void rotate(int angle);
}
```

Например, есть абстрактный класс, который определяет любую графическую фигуру.
Поскольку еще неизвестно является ли некоторая графическая фигура площадной, может ли она масштабироваться или вращаться, то данный класс пока не реализует никаких интерфейсов.

```java
import java.awt.*;

// Абстрактный класс графических фигур
public abstract class Shape {
    // Цвет фигуры
    private Color color;

    // Методы доступа к закрытым полям
    
    // Конструкторы

    // Абстрактный метод для рисования фигур 
    public abstract void draw(Graphics2D g);
}
```

Например, объекты класса, представляющие прямоугольники, являются площадными, масштабируются и вращаются.  Поэтому их класс реализует интерфейсы Area, Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих прямоугольники,
// реализует интерфейсы Area, Scalable, Rotatable
public class Rectangle extends Shape implements Area, Scalable, Rotatable {
    // Нестатические поля, задающие состояние объектов типа Rectangle
    // Координаты левого верхнего угла органичивающей рамки фигуры
    private int x, y;   
    // Ширина и высота
    private int width, height;
    // Угол поворота
    private int angle;
    
    // Методы доступа к закрытым полям
    
    // Конструкторы

    // Переопределение абстрактных методов, 
    // унаследованных от интерфейса Scalable    
    public int area() {
        return width * height;
    }
    
    // Переопределение абстрактных методов, 
    // унаследованных от интерфейса Scalable    
    public void scale(float factor) {
        scale(factor, factor);
    }
    
    public void scale(float wFactor, float hFactor) {
        // Проверка допустимости значения с помощью констант Scalable
        if (wFactor >= MIN_FACTOR && wFactor<= MAX_FACTOR)
            setWidth(Math.round(width * wFactor));
        
        // Проверка допустимости значения с помощью констант Scalable
        if (hFactor>= MIN_FACTOR && hFactor<= MAX_FACTOR)
            setHeight(Math.round(height * hFactor));
    }

    // Переопределение абстрактного метода, 
    // унаследованного от интерфейса Rotatable    
    public void rotate(int angle) {
        // Проверка допустимости значения с помощью констант Rotatable
        if (angle >= MIN_ANGLE && angle <= MAX_ANGLE)
            setAngle(angle);
    }

    // Переопределение абстрактного метода, 
    // унаследованного от суперкласса Shape    
    public void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

Например, объекты класса, представляющие точки, не являются площадными, не масштабируются и не вращаются.  Поэтому их класс не реализует интерфейсы Area, Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих точки,
// не реализует никаких интерфейсов
public class Point extends Shape {
    // Координаты точки
    private int x, y;
    
    // Методы доступа к закрытым полям 
        
    // Конструкторы

    // Переопределение абстрактных методов
    public abstract void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

Например, объекты класса, представляющие линии, не являются площадными, но могут масштабироваться и вращаться.  Поэтому их класс не реализует интерфейс Area, но реализует интерфейсы Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих линии,
// реализует только интерфейсы Scalable, Rotatable
public class Line extends Shape implements Scalable, Rotatable {
    // Координаты линии задаются двумя точками
    private x1, y1, x2, y2;
    
    // Методы доступа к закрытым полям
        
    // Конструкторы

    // Переопределение абстрактных методов
    public abstract void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

### Методы по умолчанию

### Наследование интерфейсов

### Вложенные интерфейсы


## Перечисления

_Перечисления_ — это специальный тип данных для представления набора предопределенных константных значений.

Перечисление объявляется с помощью ключевого слова `enum`.

```java
// Дни недели
public enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```

Перечисленные константы являются публичными и статическими.
```java
public class Main {
    public static void main(String[] args) {
        Day today = Day.MONDAY;
        
        if (today == Day.SATURDAY || today == Day.SUNDAY) {
            System.out.println("Выходной!");
        } else {
            System.out.println("Рабочий день");
        }
        
        // Перебор всех значений
        for (Day day : Day.values()) {
            System.out.println(day);
        }
    }
}
```

### Перечисление с методами и конструкторами

Перечисление может включать поля, конструкторы и методы.

```java
// Цвета заданной палитры
public enum PaletteColor {
    RED("красный"),
    GREEN("зеленый"),
    BLUE("синий"),
    YELLOW("желтый"),
    BLACK("черный");
    
    // Поле
    private final String russianName;
    
    // Конструктор
    PaletteColor(String russianName, ) {
        this.russianName = russianName;
    }
    
    // Методы
    public String getRussianName() {
        return russianName;
    }
    
    public boolean isCold() {
        return this == BLUE || this == GREEN;
    }

    public boolean isWarm() {
        return this == RED || this == YELLOW;
    }
}
```

Создадим перечисление для представления цветов заданной палитры с расширенной функциональностью.

```java
public enum PaletteColor {
    // Основные цвета
    RED(255, 0, 0),
    GREEN(0, 255, 0),
    BLUE(0, 0, 255),
    
    // Дополнительные цвета
    YELLOW(255, 255, 0),
    ORANGE(255, 165, 0),
    PURPLE(128, 0, 128),
    PINK(255, 192, 203),
    BROWN(165, 42, 42),
    
    // Ахроматические цвета
    BLACK(0, 0, 0),
    WHITE(255, 255, 255),
    GRAY(128, 128, 128),
    LIGHT_GRAY(211, 211, 211),
    DARK_GRAY(169, 169, 169),
    
    // Специальные цвета
    CYAN(0, 255, 255),
    MAGENTA(255, 0, 255),
    GOLD(255, 215, 0),
    SILVER(192, 192, 192);
    
    private final int red;
    private final int green;
    private final int blue;
    
    // Конструктор
    PaletteColor(int red, int green, int blue) {
        this.red = red;
        this.green = green;
        this.blue = blue;
    }
    
    // Геттеры для компонентов цвета
    public int getRed() {
        return red;
    }
    
    public int getGreen() {
        return green;
    }
    
    public int getBlue() {
        return blue;
    }
    
    // Метод для получения цвета в формате RGB
    public String getRGB() {
        return String.format("RGB(%d, %d, %d)", red, green, blue);
    }
    
    // Метод для создания объекта типа Color 
    public Color toColor() {
        return new Color(red, green, blue);
    }
    
    // Метод для проверки является ли цвет светлым
    public boolean isLight() {
        // Простая формула для определения яркости
        double brightness = (red * 0.299 + green * 0.587 + blue * 0.114) / 255;
        return brightness > 0.5;
    }
    
    // Статический метод для получения случайного цвета
    public static PaletteColor getRandom() {
        PaletteColor[] colors = values();
        int randomIndex = (int)(Math.random() * colors.length);
        return colors[randomIndex];
    }
    
    // Метод для поиска цвета по названию (без учета регистра)
    public static PaletteColor findByName(String name) {
        for (PaletteColor color : values()) {
            if (color.name().equalsIgnoreCase(name)) {
                return color;
            }
        }
        return null;
    }
}
```

Рассмотрим использование данного перечисления.
```java
public class Shape {
    protected ColorPalette color;
    protected int x, y;
    
    public Shape(ColorPalette color, int x, int y) {
        this.color = color;
        this.x = x;
        this.y = y;
    }
    
    public void draw() {
        System.out.printf("Рисую фигуру цветом %s в позиции (%d, %d)%n", 
            color.name(), x, y);
    }
    
    // Геттеры и сеттеры
    public ColorPalette getColor() {
        return color;
    }
    
    public void setColor(ColorPalette color) {
        this.color = color;
    }
}
```

```java
// Пример использования
public class Main {
    public static void main(String[] args) {
        // Создание фигур с цветами из палитры
        Shape rect = new Rectangle(ColorPalette.RED, 10, 10, 50, 30);
        Shape circle = new Ellipse(ColorPalette.OCEAN_BLUE, 30, 40, 40, 40);
        
        // Случайный цвет
        Shape randomShape = new Triangle(ColorPalette.getRandomColor(), 50, 20, 40, 25);
        
        // Демонстрация информации о цветах
        System.out.println("=== ПАЛИТРА ЦВЕТОВ ===");
        for (ColorPalette color : ColorPalette.values()) {
            System.out.printf("%s: %s %s%n", 
                color.name(), 
                color.getRGB(),
                color.isLightColor() ? "(светлый)" : "(темный)");
        }
        
        // Рисование фигур
        rect.draw();
        circle.draw();
        randomShape.draw();
    }
}
```

### Вложенные перечисления

## Задания


## Вопросы

1.	

## Ресурсы

