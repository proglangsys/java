# Занятие 11. Потоки Stream API

Stream API позволяет работать с коллекциями и данными в функциональном стиле, предоставляя возможности для декларативной обработки данных.

## Потоки Stream API

*Поток (Stream)* — это последовательность элементов, поддерживающих последовательные и параллельные агрегатные операции.

Характеристики Stream:
-   Не хранит данные (в отличие от коллекций)
-   Не изменяет исходные данные
-   Ленивые вычисления (выполняется только при терминальной операции)
-   Может быть бесконечным
-   Одноразовый (после использования закрывается)

### Создание потоков

```java
// Из коллекций
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> streamFromList = list.stream();

// Из массива
String[] array = {"a", "b", "c"};
Stream<String> streamFromArray = Arrays.stream(array);

// Из значений
Stream<String> streamOfValues = Stream.of("a", "b", "c");

// Бесконечные потоки
Stream<Integer> infiniteStream = Stream.iterate(0, n -> n + 1);
Stream<Double> randomStream = Stream.generate(Math::random);

// Из файлов
Stream<String> lines = Files.lines(Paths.get("file.txt"));

// Примитивные потоки
IntStream intStream = IntStream.range(1, 10);
LongStream longStream = LongStream.of(1L, 2L, 3L);
DoubleStream doubleStream = DoubleStream.generate(Math::random);
```

### Операции над потоками

#### Промежуточные операции

Фильтрация:
```java
List<String> list = Arrays.asList("apple", "banana", "cherry", "date");

// filter - фильтрация по условию
list.stream()
    .filter(s -> s.startsWith("a"))
    .forEach(System.out::println); // apple

// distinct - удаление дубликатов
Stream.of(1, 2, 2, 3, 3, 3)
      .distinct()
      .forEach(System.out::println); // 1, 2, 3
```

Преобразование:
```java
// map - преобразование элементов
list.stream()
    .map(String::toUpperCase)
    .forEach(System.out::println); // APPLE, BANANA, CHERRY, DATE

// flatMap - преобразование и "разворачивание"
List<List<String>> nestedList = Arrays.asList(
    Arrays.asList("a", "b"),
    Arrays.asList("c", "d")
);
nestedList.stream()
         .flatMap(Collection::stream)
         .forEach(System.out::println); // a, b, c, d

// mapToInt, mapToLong, mapToDouble - преобразование в примитивные потоки
list.stream()
    .mapToInt(String::length)
    .forEach(System.out::println); // 5, 6, 6, 4
```

Ограничение и пропуск:
```java
// limit - ограничение количества элементов
Stream.iterate(1, n -> n + 1)
      .limit(5)
      .forEach(System.out::println); // 1, 2, 3, 4, 5

// skip - пропуск первых элементов
Stream.of(1, 2, 3, 4, 5)
      .skip(2)
      .forEach(System.out::println); // 3, 4, 5

// takeWhile (Java 9+) - берет элементы пока условие истинно
Stream.of(1, 2, 3, 4, 5, 1, 2)
      .takeWhile(n -> n < 4)
      .forEach(System.out::println); // 1, 2, 3

// dropWhile (Java 9+) - пропускает элементы пока условие истинно
Stream.of(1, 2, 3, 4, 5, 1, 2)
      .dropWhile(n -> n < 4)
      .forEach(System.out::println); // 4, 5, 1, 2
```

Сортировка:
```java
// sorted - сортировка
Stream.of(3, 1, 4, 1, 5)
      .sorted()
      .forEach(System.out::println); // 1, 1, 3, 4, 5

// sorted с компаратором
list.stream()
    .sorted(Comparator.reverseOrder())
    .forEach(System.out::println); // date, cherry, banana, apple
```

#### Терминальные операции

Сбор результатов:
```java
List<String> fruits = Arrays.asList("apple", "banana", "cherry", "date");

// collect - сбор в коллекцию
List<String> resultList = fruits.stream()
                               .filter(s -> s.length() > 5)
                               .collect(Collectors.toList());

// toArray - сбор в массив
String[] array = fruits.stream().toArray(String[]::new);

// joining - объединение строк
String joined = fruits.stream()
                     .collect(Collectors.joining(", "));

// toMap - сбор в Map
Map<String, Integer> map = fruits.stream()
                                .collect(Collectors.toMap(
                                    s -> s,
                                    String::length
                                ));

// groupingBy - группировка
Map<Integer, List<String>> groupedByLength = fruits.stream()
    .collect(Collectors.groupingBy(String::length));
// {4=[date], 5=[apple], 6=[banana, cherry]}

// partitioningBy - разделение на две группы
Map<Boolean, List<String>> partitioned = fruits.stream()
    .collect(Collectors.partitioningBy(s -> s.length() > 5));
```

Поиск и проверка:
```java
// anyMatch - хотя бы один элемент удовлетворяет условию
boolean hasApple = fruits.stream().anyMatch(s -> s.equals("apple"));

// allMatch - все элементы удовлетворяют условию
boolean allLong = fruits.stream().allMatch(s -> s.length() > 3);

// noneMatch - ни один элемент не удовлетворяет условию
boolean noZ = fruits.stream().noneMatch(s -> s.contains("z"));

// findFirst - первый элемент
Optional<String> first = fruits.stream().findFirst();

// findAny - любой элемент (полезно в параллельных потоках)
Optional<String> any = fruits.stream().findAny();
```

Агрегатные операции:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// count - количество элементов
long count = numbers.stream().count();

// min/max - минимальный/максимальный элемент
Optional<Integer> min = numbers.stream().min(Integer::compareTo);
Optional<Integer> max = numbers.stream().max(Integer::compareTo);

// sum - сумма (только для примитивных потоков)
int sum = numbers.stream().mapToInt(Integer::intValue).sum();

// average - среднее значение (только для примитивных потоков)
OptionalDouble avg = numbers.stream().mapToInt(Integer::intValue).average();

// reduce - сворачивание
Optional<Integer> sumReduce = numbers.stream().reduce(Integer::sum);
Integer product = numbers.stream().reduce(1, (a, b) -> a * b);
```

#### Примитивные потоки:
```java
IntStream intStream = IntStream.range(1, 6);

// Специфичные операции для примитивных потоков
int[] evenSquares = intStream
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .toArray(); // [4, 16]

// Сумма, среднее, статистика
IntSummaryStatistics stats = IntStream.of(1, 2, 3, 4, 5)
    .summaryStatistics();
System.out.println(stats.getSum());     // 15
System.out.println(stats.getAverage()); // 3.0
System.out.println(stats.getCount());   // 5
```

#### Параллельные потоки

```java
List<String> largeList = // большой список

// Создание параллельного потока
Stream<String> parallelStream = largeList.parallelStream();

// Преобразование последовательного в параллельный
Stream<String> parallel = largeList.stream().parallel();

// Пример использования
long count = largeList.parallelStream()
    .filter(s -> s.length() > 10)
    .count();

// Важно: операции должны быть thread-safe
List<String> result = Collections.synchronizedList(new ArrayList<>());
largeList.parallelStream()
    .filter(s -> s.length() > 10)
    .forEach(result::add);
```

## Обработка коллекции объектов

```java
class Person {
    private String name;
    private int age;
    private String city;
    
    // конструктор, геттеры, сеттеры
}

List<Person> people = Arrays.asList(
    new Person("Alice", 25, "London"),
    new Person("Bob", 30, "New York"),
    new Person("Charlie", 35, "London"),
    new Person("Diana", 28, "Paris")
);

// Люди из Лондона старше 25 лет, отсортированные по имени
List<String> londoners = people.stream()
    .filter(p -> "London".equals(p.getCity()))
    .filter(p -> p.getAge() > 25)
    .sorted(Comparator.comparing(Person::getName))
    .map(Person::getName)
    .collect(Collectors.toList());

// Группировка по городу
Map<String, List<Person>> byCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));

// Средний возраст по городам
Map<String, Double> avgAgeByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.averagingInt(Person::getAge)
    ));
```

## Задания

**10-1** — 1 балл

Вариант I

- Cоздайте сущностный класс `Student` с полями (имя, возраст, группа, средний балл) и сгенерируйте список студентов.
- Используя Stream API:
	- Создайте метод, который возвращает список студентов, чей возраст больше 20 лет.
	- Создайте метод, который возвращает список только имен студентов из группы "1".
	- Создайте метод, который возвращает список студентов, отсортированный по возрасту (по возрастанию).
	- Создайте метод, который находит любого студента с оценкой выше 4.5.

Вариант II

- Cоздайте сущностный класс `Student` с полями (имя, возраст, группа, средний балл) и сгенерируйте список студентов.
- Используя Stream API:
	- Создайте метод, который возвращает список студентов, у которых средний балл выше 4.0.
	- Создайте метод, который возвращает список только имен студентов из группы "2".
	- Создайте метод, который возвращает список студентов, отсортированный по среднему баллу (по убыванию).
	- Создайте метод, который находит первого студента в алфавитном порядке имен.

**10-2** — 1 балл

Вариант I

- Добавьте в класс `Student` поле `List<String> courses` (список курсов, которые посещает студент).
- Используя Stream API
	- Создайте метод, который вычисляет средний возраст всех студентов.    
	-  Создайте метод, который вычисляет максимальный балл среди всех студентов.
	- Создайте метод, который проверяет все ли студенты старше 18 лет.
	- Создайте метод, который возвращает `Map`, где ключ - название группы, значение - список студентов этой группы.
	- Создайте метод, который возвращает список всех уникальных курсов, которые посещают студенты.
	- Создайте метод, который находит группу с наивысшим средним баллом, и возвращает имена студентов этой группы, отсортированные по имени.

Вариант I

- Используя Stream API:
	- Создайте метод, который вычисляет средний балл всех студентов.
	- Создайте метод, который вычисляет общее количество студентов.
	- Создайте метод, который возвращает список имен топ-3 студентов с наивысшим баллом, отсортированных по убыванию балла.
	- Создайте метод, который находит группу с наивысшим средним баллом, и возвращает имена студентов этой группы, отсортированные по имени.
	- Создайте метод, который проверяет есть ли хотя бы один студент с идеальным баллом (5.0).
	- Создайте метод, который возвращает `Map`, где ключ - название группы, значение - средний балл студентов этой группы.
	- Создайте метод, который находит группу с наивысшим средним баллом, и возвращает имена студентов этой группы, отсортированные по имени.


**10-3** — 2 балла

- Разработайте систему для анализа успеваемости студентов университета. Необходимо реализовать классы и методы для обработки данных о студентах, их курсах и оценках с использованием Stream API.
- Создайте сущностный класс `Course` (преподаваемая дисциплина) с полями: название, категория (с константными значениями "Программирование", "Математический", "Гуманитарный", "Естественнонаучный"), семестр, количество часов (кредитов).
- Создайте сущностный класс `Grade` (оценка студента по курсу) с полями: имя студента, название курса, оценка (от 2.0 до 5.0), год.
- Создайте сущностный класс `Student` (студент) с полями: имя, факультет,  год обучения, список завершенных курсов.
- Используя Stream API сгенерировать отчет в виде Map с ключевой статистикой:
	- Лучший студент (по успеваемости по всем курсам)
	- Лучший факультет (по успеваемости по всем курсам)
	- Самый сложный курс (с наименьшим средним баллом по всем студентам)
	- Самая успешная категория курсов (с наибольшим средним баллом по всем студентам)
	- Общее количество сданных экзаменов (по всем студентам)

## Вопросы

1.	Есть ли в вашем коде функциональные интерфейсы?
2.	Есть ли в вашем коде одиночные лямбда-выражения?
3.	Есть ли в вашем коде блочные лямбда-выражения?
4.	Выделите в вашем коде лямбда оператор?
5.	Выделите в вашем коде параметры лямбда-выражения?
6.	Выделите в вашем коде тело лямбда-выражения?
7.	Какой функциональный интерфейс реализует то или иное лямбда-выражения в вашем коде?
8.	Какие обобщенные функциональные интерфейсы вы применяете в вашем коде?
9.	Есть ли ссылки на статические методы в вашем коде?
10. Есть ли ссылки на методы конкретных объектов в вашем коде?
11. Есть ли ссылки на методы произвольных объектов в вашем коде?
12. Есть ли ссылки на конструкторы в вашем коде?
13.	Как вы реализовали компараторы?
14.	Какие встроенные функциональные интерфейсы вы используете в вашем коде?
15.	Сколько абстрактных методов может включать функциональный интерфейс?
16.	Сколько методов по умолчанию может включать функциональный интерфейс?
17.	Какими способами можно реализовать функциональный интерфейс?
18.	Какой тип данных имеет то или иное лямбда-выражение в вашем коде?
19.	Что содержит левая часть лямбда-выражения?
20.	Что содержит правая часть лямбда-выражения?
21.	Как вы применяет StreamAPI для сортировки объектов?
22.	Как вы применяет StreamAPI для поиска объектов?
23.	Как вы применяет StreamAPI для проверка условий над объектами?
24.	Как вы применяет StreamAPI для группировки объектов?
25.	Как вы применяет StreamAPI для фильтрации объектов?
26.	Как вы применяет StreamAPI для преобразования объектов?
27.	Как вы применяет StreamAPI для плоского преобразования объектов?
28.	Как вы используете обобщения в вашем коде?
29.	Есть в вашем коде параметры типов?
30.	Есть в вашем коде аргументы типов?

## Дополнительные ресурсы
