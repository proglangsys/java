# Экзамен

## Критерии оценки

Количество баллов N вычисляется следующим образом:

**N = 45 + T + P + L**, где 

- **T** — количество правильных ответов на вопросы по теории: 1 вопрос = 1 балл (максимум 10 баллов)
- **P** — количество выполненных заданий по практике:  1 задание = 5 балл (максимум 15 баллов)
- **L** — количество заданий лабораторных работ, уже сданных в течение семестра до экзамена: 1 задание = 1 балл

## Порядок сдачи

1. [Получить номер билета](https://xn--80akjcielidvhr6cf.xn--p1ai/) — _это номер задания (практики) и номер темы (теории), которые необходимо сдать_
2. Подготовиться (45 минут)
3. Сдать практику (в форме собеседования)
4. Сдать теорию (в форме собеседования)

## Задания (практика)

### Часть I

> Билет включает один вариант задания из списка ниже

1.	Определить принадлежит ли одна последовательность чисел другой последовательности
2.	Найти произведение двух матриц
3.	Возвести матрицу в степень
4.	Найти максимум среди сумм элементов диагоналей квадратной матрицы, параллельных главной диагонали
5.	Найти максимум среди произведений элементов диагоналей квадратной матрицы, параллельных главной диагонали
6.	Найти максимум среди средних значений элементов диагоналей квадратной матрицы, параллельных главной диагонали
7.	Найти минимум среди сумм элементов диагоналей квадратной матрицы, параллельных побочной диагонали
8.	Найти минимум среди произведений элементов диагоналей квадратной матрицы, параллельных побочной диагонали
9.	Найти минимум среди средних значений элементов диагоналей квадратной матрицы, параллельных побочной диагонали
10.	Упорядочить строки матрицы по суммам их элементов
11.	Упорядочить строки матрицы по произведениям их элементов
12.	Упорядочить строки матрицы по средним значениям их элементов
13.	Упорядочить столбцы матрицы по суммам их элементов
14.	Упорядочить столбцы матрицы по произведениям их элементов
15.	Упорядочить столбцы матрицы по средним значениям их элементов
16.	Вычислить количество отрицательных и положительных чисел в многомерном массиве чисел
17.	Найти наибольший общий делитель для последовательности чисел

*Обязательные требования:*

- Разработанное приложение должно обеспечивать ввод некоторых пользовательских параметров из командной строки и вывод результатов в командную строку

*Порядок сдачи задания:*

1. Объяснить исходный код классов (_понимать синтаксис и поток исполнения_)
3. Собрать и запустить приложение
4. Продемонстрировать работу приложения

### Часть II

> Билет включает один вариант задания из списка ниже

1.	Упорядочить лексемы в строке лексикографически
2.	Упорядочить лексемы в строке по длине
3.	Упорядочить лексемы в строке по их встречаемости
4.	Найти в строке лексему, встречающуюся наибольшее количество раз
5.	Найти в строке лексему, которая включает заданный символ наибольшее количество раз
6.	Найти в сроке лексему с наибольшим количеством согласных звуков
7.	Выбрать из строки все лексемы, являющиеся палиндромами
8.	Выбрать из строки все подстроки, заключенные внутри пар двойных кавычек с учетом    экранирования
9.	Заменить в текстовом файле все вхождения одной строки на другую строку
10.	Извлечь все лексемы из текстового файла и записать их в виде списка в другой текстовый файл
11.	Извлечь сигнатуры методов и конструкторов из файла с исходным кодом Java
12.	Извлечь поля и значения инициализации из файла с исходным кодом Java
13.	Сравнить два заданных текстовых файла и разницу в третий текстовый файл
14.	Сравнить структуру двух заданных директорий и записать разницу в текстовый файл
15.	Найти все текстовые файлы, содержащие заданную строку, в заданной директории
16.	Сформировать список файлов заданной директории (включая поддиректории) и записать результат в текстовый файл
17.	Изменить расширение всех файлов в заданной директории (включая поддиректории) по заданному шаблону

*Обязательные требования:*

- Разработанное приложение должно обеспечивать ввод некоторых пользовательских параметров из командной строки и вывод результатов в командную строку

*Порядок сдачи задания:*

1. Объяснить исходный код классов (_понимать синтаксис и поток исполнения_)
3. Собрать и запустить приложение
4. Продемонстрировать работу приложения

### Часть III

> Билет включает общее задание

Разработать классы, представляющие взаимосвязанные сущности некоторого предмета, который вы определяете самостоятельно

*Примеры предметов моделирования*

1. [Графические примитивы](images/uml_figures.svg)
2. [Факультет](images/uml_institute.svg)

*Последовательность выполнения задания:*

1. Предложить предмет моделирования --- несколько взаимосвязанных сущностей
2. Создать UML диаграмму классов, представляющих сущности предметной модели
3. Разработать классы, реализующие сущности предметной модели
4. Разработать демонстрационное приложение (создает и использует объекты этих классов)

*Обязательные требования:*

1. Предметная модель должна включать по крайней мере 3 связанных между собой сущности
2. Каждая сущность должна быть реализована одним открытым классом верхнего уровня
4. Каждый сущностный класс должен включать поля, методы и конструкторы
5. Каждое поле должно быть закрытым и сопровождаться парой методов (геттером и сеттером)
6. По крайней мере в одном из классов должна быть реализована перегрузка методов или конструкторов
7. По крайней мере один из классов должен наследовать другой класс с переопределением его методов
8. По крайней мере один из классов должен включать статические поля или методы
9. По крайней мере один из классов должен переопределять методы `toString`, `equals` и `hashCode`

*Порядок сдачи задания:*

1. Объяснить UML диаграмму классов предметной модели (_понимать отношения наследования, ассоциации, агрегации, композиции, зависимости_)
2. Объяснить исходный код классов, реализующие сущности предметной модели (_понимать синтаксис, конструкции, реализацию в коде принципов инкапсуляции, наследования, полиморфизма_)
3. Собрать и запустить демонстрационное приложение

## Вопросы (теория)

> Билет включает одну тему из списка ниже. Каждая тема содержит 10 и более вопросов, необходимо дать ответы на заданные вопросы по теме билета.

### Тема 1. Общие сведенья

1.	Платформа разработки и среда исполнения
2.	Байт-код и JIT компиляция 
3.	Разделители и лексемы
4.	Комментарии (строчные, блочные, doc)
5.	Блоки кода
6.	Переменные (объявление и инициализация)
7.	Main-метод
8.	Аргументы командной строки
9.	Вывод в командную строку
10.	Ввод символов с командной строки

### Тема 2. Простые типы данных и операторы

1.	Простые типы данных и литералы
2.	Завершенные переменные
3.	Область действия локальной переменной
4.	Арифметические операторы и укороченные операторы присваивания
5.	Операторы сравнения
6.	Логические операторы
7.	Операторы присваивания
8.	Побитовые операторы
9.	Тернарный оператор
10.	Приведение простых типов данных

### Тема 3. Управляющие инструкции

1.	Условная инструкция `if`
2.	Ветвление `else if`
3.	Множественное ветвление `switch`
4.	Цикл `for`
5.	Цикл `while`
6.	Цикл `do-while`
7.	Инструкция `break`
8.	Инструкция `break` по метке
9.	Инструкция `continue`
10.	Рекурсия

### Тема 4. Классы, объекты

1.	Класс (определение)
2. Объявление класса
3. Поля (объявление и инициализация)
4. Скрытие полей (ключевое слово `this`)
5. Инициализаторы
6. Создание объектов
7. Объектные ссылки, null литерал и сборка мусора
8. Обращение к полям экземпляра класса
9. Вызов методов экземпляра класса
10.	Проверка равенства двух объектов (оператор сравнения == и метод `equals()`)

### Тема 5. Методы, конструкторы

1.	Методы (объявление и реализация)
2.	Возвращаемый тип данных и инструкция `return`
3.	Передача аргументов в метод
4.	Разница между передачей аргументов по значению и по ссылки 
5.	Переменное число аргументов
6.	Перегрузка методов
7.	Конструкторы (объявление и реализация)
8.	Конструктор по умолчанию
9.	Перегрузка конструкторов
10.	Вызов перегруженного конструктора (ключевое слово `this`)

### Тема 6. Управление доступом, внутренние классы, статический контекст

1.	Инкапсуляция
2.	Открытый и закрытый уровень доступа
3.	Статические поля 
4.	Глобальные константы
5.	Внутренние классы
6.	Локальные классы
7.	Анонимные классы
8.	Статические методы
9.	Статические инициализаторы
10.	Разница между нестатическим и статическим контекстом

### Тема 7. Массивы

1.	Массив (определение)
2.	Объявление массивов
3.	Альтернативный синтаксис объявления массива
4.	Обращение к элементам массива
5.	Многомерные массивы
6.	Нерегулярные массивы
7.	Статическая инициализация массива
8.	Перебор элементов и длина массива 
9.	Цикл `for-each`
10.	Манипулирование массивами с помощью класса `Arrays`

### Тема 8. Строки

1.	Кодировка символов
2.	Неизменяемые строки типа `String`
3.	Перебор символов и длина строки
4.	Методы обработки строк
5.	Конкатенация строк
6.	Токенизация строк
7.	Форматирование строк
8.	Метод `toString()`
9.	Преобразование строк в числа
10.	Изменяемые строки типа `StringBuffer` и `StringBuilder`

### Тема 9. Наследование классов

1.	Наследование классов
2.	Разница между одиночным и множественным наследованием
3.	Вызов конструктора суперкласса
4.	Скрытие полей суперкласса (ключевое слово `super`)
5.	Полиморфизм
6.	Переопределение методов
7.	Завершенные методы
8.	Завершенные классы
9.	Абстрактные методы
10.	Абстрактные классы

### Тема 10. Интерфейсы

1.	Интерфейсы (определение)
2.	Наследование интерфейсов
3.	Реализация интерфейсов
4.	Методы по умолчанию интерфейса
5.	Закрытые методы интерфейса
6.	Статистические методы интерфейса
7.	Статистические поля интерфейса
8.	Функциональные интерфейсы
9.	Использование ссылочного типа, определяемого интерфейсом
10.	Разница между интерфейсом и абстрактным классом

### Тема 11. Пакеты, перечисления, оболочки

1.	Пакеты (определение, пространства имен)
2.	Пакетный (по умолчанию) и защищённый уровень доступа
3.	Импорт пакетов и классов
4.	Статический импорт
5.	Перечисления
6.	Создание перечислений с конструкторами, полями и методами
7.	Объектные оболочки простых типов
8.	Автоупаковка и автораспаковка
9.	Класс `Object`
10.	Методы `equals()` и `hashCode()`

### Тема 12. Обобщения

1.	Обобщенные классы
2.	Ограниченные параметры типов
3.	Аргументы типов
4.	Шаблоны аргументов
5.	Ограниченные шаблоны аргументов
6.	Обобщенные методы
7.	Обобщенные конструкторы
8.	Обобщенные интерфейсы
9.	Использование базовых типов
10.	Исключение ошибок неоднозначности

### Тема 13. Коллекции

1.	Коллекции
2.	Списки (динамический массив, связный список)
3.	Упорядоченное множество
4.	Очередь
5.	Двусторонняя очередь
6.	Стек
7.	Дерево
8.	Отображение
9.	Итераторы
10.	Компараторы

### Тема 14. Обработка исключений

1.	Исключения (определение)
2.	Инструкции `try` и `catch`
3.	Множественные инструкции `catch`
4.	Перехват исключений подклассов
5.	Вложенные блоки `try`
6.	Генерирование исключений
7.	Блок `finally`
8.	Передача исключений (ключевое слово `throws`)
9.	Встроенные классы исключений
10.	Создание классов исключений

### Тема 15. Ввод-вывод данных

1.	Потоки ввода-вывода
2.	Байтовые потоки
3.	Символьные потоки
4.	Ввод-вывод с командной строкой
5.	Сканнеры типа `Scanner`
6.	Файловый ввод-вывод
7.	Закрытие ресурсов в блоке `finally`
8.	Автоматическое закрытие ресурсов (инструкция `try` с ресурсами)
9.	Произвольный доступ к файлам
10.	Объектный ввод-вывод

### Тема 16. Многопоточное программирование

1.	Многопоточная обработка
2.	Класс `Thread`
3.	Интерфейс `Runnable`
4.	Создание и запуск нескольких потоков
5.	Определение момента завершения потока
6.	Приоритезация потоков
7.	Синхронизация потоков
8.	Использование синхронизированных методов
9.	Использование синхронизированных блоков кода
10.	Приостановка, возобновление и остановка потоков

### Тема 17. Лямбда-выражения и ссылки на методы

1.	Лямбда-выражения (определение)
2.	Функциональные интерфейсы
3.	Одиночные лямбда-выражения
4.	Блочные лямбда-выражения
5.	Использование обобщенных функциональных интерфейсов
6.	Захват переменных в лямбда-выражениях
7.	Генерация исключений в лямбда-выражениях
8.	Ссылки на методы
9.	Ссылки на конструкторы
10.	Встроенные функциональные интерфейсы
