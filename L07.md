# Занятие 7. Интерфейсы

## Пакеты

*Пакеты* — это механизм для организации классов в логические группы, что помогает избежать конфликтов имен и управлять доступом.

Объявление пакета:
```java
// Самая первая инструкция (в начале файла .java)
package com.company.project.module;

public class MyClass {
    // код класса
}
```

Физически пакет является иерархией каталогов, а имя пакета соответствует структуре каталогов:
```
com/
└── company/
    └── project/
        └── module/
            └── MyClass.java
```

Обычно, имя пакета начинается с доменного имени той организации, в которой разрабатывается советующий исходный код, записанного в обратном порядке. Такое именование пакетов позволяет избежать конфликты пространств имен.

Стандартная схема именования пакета:
```
com.[company].[project].[module].[submodule]
```

Пакеты могут иметь общую начальную часть в структуре каталогов.

Например, имеем следующие классы:
```java
package ru.isu.math.graphicaleditor;

public class GraphicalEditorApp {
    // код класса
}
 ```

 ```java
package ru.isu.math.graphicaleditor.graphics;

public abstract class Shape {
    // код класса
}
 ```
 
 ```java
package ru.isu.math.graphicaleditor.graphics;

public class Rectangle extends Shape {
    // код класса
}
```

В этом случае имеем два разных пакета:
```
ru.isu.math.graphicaleditor
ru.isu.math.graphicaleditor.graphics
```

Соответствующая структура каталогов будет выглядеть следующим образом: 
```
ru/
└── isu/
    └── math/
        └── graphicaleditor/
            ├── GraphicalEditorApp.java
            └── graphics/
                ├── Shape.java
                └── Rectangle.java
```


Внутри одного пакета нет необходимости импортировать одни классы этого пакета в другие классы этого же пакета. 
Если пакеты разные, то чтобы использовать классы одного пакета в классах другого пакеты, необходимо их импортировать.

 ```java
package ru.isu.math.graphicaleditor;

// Импорт всех классов из вложенного пакета  
import ru.isu.math.graphicaleditor.graphics.*;

public class GraphicalEditorApp {
    // код класса
}
 ```

## Управление доступом

### Инкапсуляция

_Инкапсуляция_ — это принцип ООП, который заключается в объединении данных и методов, работающих с этими данными, в единый объект, и сокрытии внутренней реализации от внешнего доступа.

Согласно этому принципу в классе необходимо выделить открытую (*интерфейсную*) часть и закрытую часть.

### Уровни доступа

Есть четыре уровня доступа к полям, методам и конструкторам:

|       Где доступно?      |    Закрытый     (`private`)    |    Пакетный     (по умолчанию)    |    Защищенный    (`protected`)    |    Открытый    (`public`)    |
|:------------------------:|:----------------------------:|:---------------------------------:|:-------------------------------:|:--------------------------:|
|     Класс                |     да                       |     да                            |     да                          |     да                     |
|     Пакет                |     нет                      |     да                            |     да                          |     да                     |
|     Пакет и подклассы    |     нет                      |     нет                           |     да                          |     да                     |
|     Любой класс          |     нет                      |     нет                           |     нет                         |     да                     |

Есть три модификатора доступа:
- `private` — закрытый уровень доступа;
- `protected` — защищенный уровень доступа;
- `public` — открытый уровень доступа.

Пакетный уровень применяется по умолчанию, поэтому не имеет модификатора. 

### Управление доступом к классам

К классам верхнего уровня возможно применить только два уровня доступа: открытый или пакетный (по умолчанию).

По умолчанию класс доступен только в своем пакете.
```java
package ru.isu.math.graphicaleditor.graphics;

// Этот класс доступен только в пакете 
// ru.isu.math.graphicaleditor.graphics
abstract class Shape {
    // Код класса
}
```

Публичный класс может быть доступен в любых других классах.
```java
package ru.isu.math.graphicaleditor.graphics;

// Этот класс доступен только везде, где он импортирован
public class Rectangle extends Shape {
    // Код класса
}
```

Публичный класс может быть импортирован в классы других пакетов.
```java
package ru.isu.math.graphicaleditor;

// Импорт всех публичных классов заданного пакета
impoprt ru.isu.math.graphicaleditor.graphics.*;

public class GraphicalEditorApp {
    // код класса
    public static void main(String[] args) {
        // Используем класс Rectangle
        Rectangle rect = new Rectangle(); 
        
        // Попытка обратиться к классу Shape
        // Shape[] shapes = {rect} // ОШИБКА!
    }
}
```

### Управление доступом к членам класса

#### Закрытый доступ:

Закрытые поля и методы объявляются с модификатором `private`.
```java
package com.company.project.module;

public class BaseClass {
    // Закрытое поле доступно только внутри данного класса
    private String secret;
    
    // Закрытый метод доступен только внутри данного класса
    private void printSecret() {
        System.out.println(secret);
    }
    
    // Другие поля и методы
}
```

Из любого другого класса доступ к закрытому полю и методу напрямую невозможен.
```java
package com.company.project;

import com.company.project.module.BaseClass;

public class MainClass {
    public static void main(String[] args) {
        BaseClass bc = new BaseClass();
        // Попытка обратиться к закрытому полю другого класса
        String s = bc.secret; // ОШИБКА!
        // Попытка обратиться к закрытому методу другого класса
        String s = bc.printSecret(); // ОШИБКА!
    }
}
```

#### Защищенный доступ

Защищенные поля и методы объявляются с модификатором `prоtected`.
```java
package com.company.project.module;

public class BaseClass {
    // Защищенное поле
    prоtected String secret;
       
    // Другие поля и методы
}
```

Подкласс имеет доступ к защищенным полям и методам, объявленным в суперклассе.
```java
package com.company.project.othermodule;

import com.company.project.module.BaseClass;

public class DerivedClass extends BaseClass {   
    // Защищенный метод
    prоtected void printSecret() {
        System.out.println(secret);
    }
    
    // Другие поля и методы
}
```

Но за пределами пакета защищенные поля и методы уже не доступны.
```java
package com.company.project; // Другой пакет

import com.company.project.module.BaseClass;
import com.company.project.othermodule.DerivedClass;

public class MainClass {
    public static void main(String[] args) {
        BaseClass bc = new BaseClass();
        // Попытка обратиться к защищенному полю другого класса
        String s = bc.secret; // ОШИБКА!

        DerivedClass dc = new DerivedClass();
        // Попытка обратиться к защищенному методу другого класса
        String s = dc.printSecret(); // ОШИБКА!
    }
}
```

#### Пакетный доступ

Пакетные поля и методы объявляются без модификатора (по умолчанию).
```java
package com.company.project.module;

public class BaseClass {
    // Пакетное поле
    String secret;
       
    // Другие поля и методы
}
```

Подкласс имеет доступ к защищенным полям и методам, объявленным в суперклассе.
```java
package com.company.project.module; // Тот же самый пакет

public class OtherClass {   
    // Пакетный метод
    void printSecret() {
        System.out.println(secret);
    }
    
    // Другие поля и методы
}
```

Но за пределами пакета пакетные поля и методы уже не доступны.
```java
package com.company.project; // Другой пакет

public class MainClass {
    public static void main(String[] args) {
        BaseClass bc = new BaseClass();
        // Попытка обратиться к пакетному полю другого класса
        String s = bc.secret; // ОШИБКА!

        OtherClass oc = new OtherClass();
        // Попытка обратиться к пакетному методу другого класса
        String s = oc.printSecret(); // ОШИБКА!
    }
}
```

#### Открытый доступ

Публичные поля и методы объявляются с модификатором `public`.

```java
package com.company.project.module;

public class BaseClass {
    // Публичное поле
    public String unsecretedId;
    
    // Публичный метод
    public void printUnsecreted() {
        System.out.println(unsecretedId);
    }
   
    // Другие поля и методы
}
```

Публичные поля и методы доступны везде где доступен сам класс, в котором они объявлены.

```java
package com.company.project;

import com.company.project.module.BaseClass;

public class MainClass {
    public static void main(String[] args) {
        BaseClass bc = new BaseClass();
        // Можно обратиться к публичному полю другого класса
        String s = bc.unsecretedId;
        // Можно обратиться к публичному методу другого класса
        bc.printUnsecreted();
    }
}
```


### Организация доступа к закрытым полям

Как правило, любое нестатическое поле объявляется закрытым (`private`) и сопровождается парой открытых (`public`) методов доступа (*аксессоры*): *геттером* (для чтения значения) и *сеттером* (для редактирования значения).

Добавление методов доступа в класс `Shape`:
```java
import java.awt.*;

public abstract class Shape {
    // Закрытые поля
    private int x, y; // Координаты базовой точки    
    private Color color; // Цвет

    // Методы доступа к закрытым полям (аксессоры)
		
    // Геттер для поля x
    public int getX() {
        return x;
    }
    
    // Сеттер для поля x
    public void setX(int x) {
        if (x >= 0 && x <= 1000)
            this.x = x;
    }
    
    // Геттер для поля y
    public int getY() {
        return y;
    }

    // Сеттер для поля y
    public void setY(int y) {
        if (y >= 0 && y <= 1000)
            this.y = y;
    }

    // Геттер для поля color
    public Color getColor() {
        return color;
    }
 
    // Сеттер для поля color
    public void setColor(Color color) {
        if (color != null)
            this.color = color;
    }

    // Конструктор
    Shape(int x, int y, Color color) {
        setX(x); // Задать значение поля x через сеттер
        setY(y); // Задать значение поля y через сеттер
        setColor(color); // Задать значение поля color через сеттер
    }

    // Метод для перемещения фигуры
    void move(int dx, int dy) {
        int newX = getX(); // Получить значение поля x через геттер
        int newY = getY(); // Получить значение поля x через геттер
        
        newX += dx; // Вычислить новое значение x-координаты
        newY += dy; // Вычислить новое значение y-координаты

        setX(newX); // Задать значение поля x через сеттер
        setY(newY); // Задать значение поля y через сеттер
    }

    // Другие поля и методы

    // Нарисовать фигуру в графическом контексте
    abstract void draw(Graphics2D g);
}
```

В подклассах доступ к закрытым членам суперкласса осуществляется через аксессоры.
```java
public class Rectangle extends Shape {
    // Поля, методы и конструкторы
     
    public static Rectangle copy(Rectangle rect) {
        Rectangle copy = new Rectangle();
        
        // Инструкции для копирования координат базовой точки
        int x = rect.getX(); // Получить значение поля x через геттер
        int y = rect.getY(); // Получить значение поля y через геттер     
        copy.setX(x); // Присвоить значение полю x через сеттер
        copy.setY(y); // Присвоить значение полю y через сеттер
        
        // Другие инструкции для копирования ширины, высоты, угла поворота и пр.
        
        return copy;
    }
}
```

Во всех других классах доступ к закрытым членам класса осуществляется через аксессоры.
```java
public class MainClass {
    public static void main(String[] args) {
        Rectangle rect = new Rectangle();
        
        // Инструкции
        
        int rectX = rect.getX(); // Получить значение поля x через геттер
        int rectY = rect.getY(); // Получить значение поля y через геттер
        
        rect.setX(10); // Присвоить значение полю x через сеттер
        rect.setY(10); // Присвоить значение полю y через сеттер
        
        // Другие инструкции
    }
}
```

## Интерфейсы

_Интерфейс_ — это спецификация (контракт) поведения объектов класса.
*Интерфейс* — это ссылочный тип данных, который представляет собой набор абстрактных методов (до Java 8) и глобальных констант. 

Класс реализует абстрактные методы одного или нескольких интерфейсов, тем самым обеспечивается описанное интерфейсом поведение объектов этого класса.

Интерфейс объявляется с помощью ключевого слова `interface`. Интерфейс содержит абстрактные методы (ключевое слово `abstract` указывать необязательно).

Интерфейс может включать публичные статические завершенные переменные (глобальные константы). При этом ключевые слова `public`, `static`, и `final` в объявлении таких констант необязательно.

Интерфейс может быть реализован в классе. Объявление класса включает ключевое слово `implements`, после которого через запятую перечисляются имена реализуемых интерфейсов. Все абстрактные методы, объявленные в этих интерфейсах, должны быть переопределены в классе.

Рассмотрим иерархию классов, объекты которых представляют графические фигуры, и интерфейсов, определяющих некоторое поведение этих объектов.

```java
// Интерфейс, определеляющий поведения масштабирования фигур
public interface Scalable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение множителя масштабирования
    float MIN_FACTOR = 0.01F, MAX_FACTOR = 100.0F; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Масштабировать фигуру по ширине и высоте пропорционально
    void scale(float factor);
    // Масштабировать фигуру по ширине и высоте раздельно
    void scale(float wFactor, float hFactor);
}
```

```java
// Интерфейс, определеляющий поведения масштабирования фигур
public interface Scalable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение множителя масштабирования
    float MIN_FACTOR = 0.01F, MAX_FACTOR = 100.0F; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Масштабировать фигуру по ширине и высоте пропорционально
    void scale(float factor);
    // Масштабировать фигуру по ширине и высоте раздельно
    void scale(float wFactor, float hFactor);
}
```

```java
// Интерфейс, определеляющий поведения вращения фигур
public interface Rotatable {
    // Константы (неявно public static final)
    // Минимальное м максимальное значение угла поворота
    int MIN_ANGLE = -360, MAX_ANGLE = 360; 
    
    // Абстрактные методы (неявно public abstract)
    
    // Повернуть фигуру на заданный угол
    void rotate(int angle);
}
```

Например, есть абстрактный класс, который определяет любую графическую фигуру.
Поскольку еще неизвестно является ли некоторая графическая фигура площадной, может ли она масштабироваться или вращаться, то данный класс пока не реализует никаких интерфейсов.

```java
import java.awt.*;

// Абстрактный класс графических фигур
public abstract class Shape {
    // Цвет фигуры
    private Color color;

    // Методы доступа к закрытым полям
    
    // Конструкторы

    // Абстрактный метод для рисования фигур 
    public abstract void draw(Graphics2D g);
}
```

Например, объекты класса, представляющие прямоугольники, являются площадными, масштабируются и вращаются.  Поэтому их класс реализует интерфейсы Area, Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих прямоугольники,
// реализует интерфейсы Area, Scalable, Rotatable
public class Rectangle extends Shape implements Area, Scalable, Rotatable {
    // Нестатические поля, задающие состояние объектов типа Rectangle
    // Координаты левого верхнего угла органичивающей рамки фигуры
    private int x, y;   
    // Ширина и высота
    private int width, height;
    // Угол поворота
    private int angle;
    
    // Методы доступа к закрытым полям
    
    // Конструкторы

    // Переопределение абстрактных методов, 
    // унаследованных от интерфейса Scalable    
    public int area() {
        return width * height;
    }
    
    // Переопределение абстрактных методов, 
    // унаследованных от интерфейса Scalable    
    public void scale(float factor) {
        scale(factor, factor);
    }
    
    public void scale(float wFactor, float hFactor) {
        // Проверка допустимости значения с помощью констант Scalable
        if (wFactor >= MIN_FACTOR && wFactor<= MAX_FACTOR)
            setWidth(Math.round(width * wFactor));
        
        // Проверка допустимости значения с помощью констант Scalable
        if (hFactor>= MIN_FACTOR && hFactor<= MAX_FACTOR)
            setHeight(Math.round(height * hFactor));
    }

    // Переопределение абстрактного метода, 
    // унаследованного от интерфейса Rotatable    
    public void rotate(int angle) {
        // Проверка допустимости значения с помощью констант Rotatable
        if (angle >= MIN_ANGLE && angle <= MAX_ANGLE)
            setAngle(angle);
    }

    // Переопределение абстрактного метода, 
    // унаследованного от суперкласса Shape    
    public void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

Например, объекты класса, представляющие точки, не являются площадными, не масштабируются и не вращаются.  Поэтому их класс не реализует интерфейсы Area, Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих точки,
// не реализует никаких интерфейсов
public class Point extends Shape {
    // Координаты точки
    private int x, y;
    
    // Методы доступа к закрытым полям 
        
    // Конструкторы

    // Переопределение абстрактных методов
    public abstract void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

Например, объекты класса, представляющие линии, не являются площадными, но могут масштабироваться и вращаться.  Поэтому их класс не реализует интерфейс Area, но реализует интерфейсы Scalable, Rotatable.

```java
import java.awt.*;

// Класс объектов, представляющих линии,
// реализует только интерфейсы Scalable, Rotatable
public class Line extends Shape implements Scalable, Rotatable {
    // Координаты линии задаются двумя точками
    private x1, y1, x2, y2;
    
    // Методы доступа к закрытым полям
        
    // Конструкторы

    // Переопределение абстрактных методов
    public abstract void draw(Graphics2D g) {
        // Инструкции для отрисовки фигуры на графическом контексте
    }
}
```

### Методы по умолчанию

### Наследование интерфейсов


## Перечисления


## Класс `Object`

Метод `toString`
Метод `equals`
Метод `hashCode`

## Задания

**Часть I**

- Разработать абстрактный класс «Shape» для представления графических фигур с абстрактным метод рисования на графическом контексте.

- Разработать интерфейс «Scalable», определяющий поведения масштабируемых графических фигур: в интерфейсе должны быть определены абстрактные методы масштабирования, глобальные константы, определяющие минимальное и максимальное значение коэффициента масштабирования.  

- Разработать класс «Rectangle», унаследованный от класса «Shape», для представления прямоугольников: класс должен реализовывать абстрактные методы интерфейса «Scalable». Переопределенные методы интерфейса «Scalable» должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения коэффициента масштабирования.

**Часть II**

- Разработать интерфейс «Rotatable», определяющий поведения поворачиваемых графических фигур: в интерфейсе должны быть определены абстрактные методы поворота фигуры на заданный угол, глобальные константы, определяющие минимальное и максимальное значение угла поворота.

- Разработать класс «Ellipse», унаследованный от класса «Shape», для представления эллипсов: класс должен реализовывать абстрактные методов интерфейсов «Scalable» и «Rotatable». Переопределенные методы интерфейса «Scalable» должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения Переопределенные методы интерфейса «Scalable» должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения коэффициента масштабирования. Переопределенные методы интерфейса «Rotatable» должны выполнять валидацию передаваемых параметров с учетом минимального и максимального значения угла поворота.

- Дополнить класс «Rectangle» статическим методом создания вписанного эллипса.
Дополнить класс «Ellipse» статическим методом создания охватывающего прямоугольника.

- Разработать программу позволяющую создавать и рисовать (в графическом файле) прямоугольники и эллипсы с возможностью их масштабирования и поворота.

- Создать серию изображений одного массива графических фигур с поворотами на 0&deg;, 45&deg;, 90&deg; и масштабами 50%, 100%, 200%.

**Часть III**

- Разработать класс, реализующий операции над матрицами: транспонирование, сложение двух матриц, умножение матрицы на число. Каждая операция должна быть реализована одним открытым статическим методом. Класс должен иметь только один закрытый конструктор.

- Продемонстрировать использование данного класса для выполнения операций над матрицами.

## Вопросы

1.	Абстрактные методы
2.	Переопределение методов
3.	Интерфейсы
4.	Расширение интерфейсов
5.	Реализация интерфейсов
6.	Принципы ООП: Полиморфизм
7.	Приведение ссылочных типов данных
8.	Статические поля и методы

## Ресурсы

1. Г. Шилдт. Java Руководство для начинающих. Главы 7-8
