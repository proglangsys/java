# Занятие 6. Классы и объекты (II)

## Наследование классов

_Наследования классов_ — это отношение между двумя классами, в котором один класс (_подкласс_) расширяет другой класс (_суперкласс_) дополнительными полями и методами. 

 - _Суперкласс_ — это класс, от которого производится наследование (расширение).
 -  _Подкласс_ — это класс, который наследует (расширяет) общий класс.

Другие названия:
- _Суперкласс_ = *Базовый класс* = *Родительский класс* = *Предок*
- _Подкласс_ = *Производный класс* = *Дочерний класс* = *Потомок*

> Java допускает только одиночное наследование классов
 
Для того чтобы один класс наследовал другой, необходимо в его объявлении указать суперкласс после ключевого слова `extends`. 

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    String firstName, lastName;
    int age;
    
    // Методы экземпляра суперкласса
    String greeting() {
        return "Hello, my name " + firstName + " " + lastName;
    }
    
    // Конструкторы
}

// Подкласс
public class Student extends Person {
    // Переменные экземпляра подкласса
    String studentId;
    int[] scores; 
    
    // Методы экземпляра подкласса
    int averageScore() {
        int sum = 0;
        for (int score : scores)
            sum += score;
        return sum / scores.length;
    }
    
    // Конструкторы
}
```

Объекты подкласса обладают состоянием и поведением определенным совместно в суперклассе и подклассе.

```java
// Суперкласс
public class MainClass {
    public static void main(String[] args) {
        Person p;
        Student s;
        // Создание объектов классов Person и Student 
        // Инициализация переменных p и s
        
        System.out.println("Hello, I am a person");
        // Обращение к методу объекта суперкласса
        System.out.println(p.greeting); 

        System.out.println("Hello, I am a student");
        // Обращение к методам объекта подкласса 
        System.out.println(s.greeting); 
        System.out.printf("My average score is %d%n", s.averageScore());
    }
}
```

Доступные поля и методы суперкласса могут использоваться в подклассе как собственные.

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    String firstName, lastName;
    int age;
    
    // Конструкторы
}

// Подкласс
public class Student extends Person {
    // Переменные экземпляра подкласса
    String studentId;
    int[] scores; 
  
    // Методы экземпляра подкласса
    String info() {
        String template = "%s %s (ID: %s)%n";
        // Обращение к полям, объявленным в суперклассе
        return String.format(template, firstName, lastName, studentId);
    }
    
    // Конструкторы
}
```

## Ключевое слово `super`

Скрытие полей экземпляра суперкласса полями экземпляра подкласса

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    int title;
}

// Подкласс
public class Student extends Person {
    // Переменные и методы экземпляра подкласса
    int title; 
}
```

Скрытие полей экземпляра суперкласса локальными переменными методов экземпляра подкласса

### Вызов конструктора суперкласса 

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    String firstName, lastName;
    int age;
    
    // Конструктор в суперклассе
    Person(String firstName, String lastName, int age) {
        // Инициализация полей, объявленных в суперклассе
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
}

// Подкласс
public class Student extends Person {
    // Переменные и методы экземпляра подкласса
    String studentId;
    int[] scores; 
    
    // Конструктор в подклассе
    Student(String firstName, String lastName, int age, String studentId) {
        // Обязательный вызов конструктора суперкласса
        super(firstName, lastName, age);
        // Инициализация полей, объявленных в подклассе
        this.studentId;
        scores = new int[10];
    }    
}
```

Вызов конструктора безаргументного конструктора суперкласса по умолчанию

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    String firstName, lastName;
    int age;
    
    // Безаргументный конструктор
    Person() {
    }
}

// Подкласс
public class Student extends Person {
    // Переменные и методы экземпляра подкласса
    String studentId;
    int[] scores; 
    
    // Конструктор в подклассе
    Student(String firstName, String lastName, int age, String studentId) {
        // Компилятор добавит вызов безаргументного конструктора
        // super();
        // Инициализация полей, объявленных в суперклассе
        super.firstName = firstName;
        super.lastName = lastName;
        super.age = age;
        // Инициализация полей, объявленных в подклассе
        this.studentId;
        scores = new int[10];
    }    
}
```

## Переопределение методов



## Абстрактные классы

Абстрактный метод не имеет реализации; объявляется с ключевым словом `abstract`. Если в классе объявлен абстрактный метод, то и сам класс должен быть объявлен как абстрактный с помощью ключевого слова `abstract`. Абстрактный класс не может иметь объектов; представляет абстрактные сущности.
```java
import java.awt.*;

// Абстрактный класс

public abstract class Shape {
    // Координаты базовой точки
    int x, y;
    // Цвет
    Color color;

    // Конструктор
    Shape(int x, int y, Color color) {
        this.x = x;
        this.y = y;
        this.color = color;
    }

    // Переместить фигуру
    void move(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // Абстрактные методы

    // Вычислить площадь фигуры
    abstract int area();
    
    // Нарисовать фигуру в графическом контексте
    abstract void draw(Graphics2D g);
}
```

### Наследование абстрактных классов

_Наследования классов_ — отношение между двумя классами, в котором один специализированный класс (_подкласс_) расширяет другой общий класс (_суперкласс_) дополнительными полями и методами.

_Суперкласс_ — общий класс, от которого производится наследование (расширение).

_Подкласс_ — специализированный класс, который наследует (расширяет) общий класс.

Объекты подкласса обладают состоянием и поведением определенным совместно суперклассом и подклассом.

Для того чтобы один класс наследовал другой, необходимо в его объявлении указать суперкласс после ключевого слова `extends`. Доступные поля и методы суперкласса могут использоваться в подклассе как собственные.
```java
import java.awt.*;

public class Rectangle extends Shape {
    // Поля
    int width, height;

    // Конструктор
    Rectangle(int x, int y, int width, int height, Color color) {
        super(x, y, color); // Обязательный вызов конструктора суперкласса
        this.width = width;
        this.height = height;
    }

    // Переопределение абстрактных методов

    // Вычислить площадь
    int area() {
        return width * height;
    }

    // Нарисовать прямоугольник в графическом контексте
    void draw(Graphics2D g) {
        g.setColor(color);
        g.fillRect(x, y, width, height);
    }
}
```

## Полиморфизм

_Полиморфизм_ — «один интерфейс, множество реализаций».

Полиморфизм связан с наследованием, т.к. наследование позволяет переопределять методы. Например, создадим суперкласс `Shape` с методом `draw`.
```java
public abstract class Shape {
    int x, y;
    Color color;

    // ... методы и конструкторы

    // Нарисовать фигуру в графическом контексте
    abstract void draw(Graphics2D g);
}
```

Данный метод будет переопределен в каждом подклассе: `Line`, `Rectangle`, `Ellipse`.

Подкласс `Line` расширяет суперкласс `Shape`
```java
public class Line extends Shape {
    int x1, y1, x2, y2;

    // ... методы и конструкторы

    // Переопределение метода
    void draw(Graphics2D g) {
        g.setColor(color);
        g.drawLine(x1,y1,x2,y2);
    }
}
```

Подкласс `Rectangle` расширяет суперкласс `Shape`
```java
public class Rectangle extends Shape implements Scalable {
    // Поля
    private int width, height;

    // ... методы и конструкторы

    // Переопределение метода
    public void draw(Graphics2D g) {
        g.setColor(color);
        g.fillRect(x, y, width, height);
    }
}
```

Подкласс `Ellipse` расширяет суперкласс `Shape`
```java
public class Ellipse extends Rectangle {
    // ... методы и конструкторы

    // Переопределение метода
    public void draw(Graphics2D g) {
        g.setColor(color);
        g.drawOval(x, y, width, height);
    }
}
```

Таким образом метод «draw», объявленный в суперклассе, является единым интерфейсом. При этом каждый подкласс предоставляет собственную реализацию этого метода. Создадим объекты этих подклассов, наследование позволяет объявлять их с типом данных, определенным суперклассом. Однако поведение объектов определяется их классами. Поэтому отрисовка созданных графических фигур на графическом контексте выполняется корректно.
```java
// Создать линию
Shape line = new Line(100,200, 300, 300, Color.RED);

// Создать прямоугольник
Shape rect = new Rectangle(0, 0, 50, 100, Color.GRAY);

// Создать эллипс
Shape ellipse = new Ellipse(100, 100, 100, 100, Color.GREEN);

// Создать массив графических фигур
Shape shapes[] = {line, rect, ellipse};

// Нарисовать все графические фигуры 
for (Shape shape: shapes)
    shape.draw(g);
```
## Статические поля и методы


## Задания

**6-1** — 1 балл

- Разработать абстрактный класс `Shape` в пакете `ru.isu.math.graphics` для представления графических фигур.
- В классе `Shape` должны быть объявлены нестатические поля (координаты левого верхнего угла ограничивающей рамки, ширина и высота ограничивающей рамки, цвет контура, цвет заливки, угол поворота), абстрактные методы (перемещения, вращения, масштабирования, вычисления площади, отрисовки на графическом контексте) и конструкторы с аргументами.
- Разработать класс `Rectangle` в пакете `ru.isu.math.graphics` для представления прямоугольников: класс должен быть унаследован от класса «Shape».
- В классе `Rectangle` должны быть реализованы методы, переопределяющие абстрактные методы, унаследованные от класса `Shape`.
- Конструкторы подкласса `Rectangle` должны содержать явные вызовы конструктора суперкласса `Shape`.

**6-2** — 1 балл

- Разработать класс `Ellipse` в пакете `ru.isu.math.graphics` для представления эллипсов: класс должен быть унаследован от класса `Shape`.
- В классе `Ellipse` должны быть реализованы методы, переопределяющие абстрактные методы, унаследованные от класса `Shape`.
- Конструкторы подкласса `Ellipse` должны содержать явные вызовы конструктора суперкласса `Shape`.
- Разработать класс `Triangle` для представления треугольников: класс должен быть унаследован от класса `Shape`; в классе должно быть переопределение абстрактных методов из класса `Shape`.
- В классе `Triangle` должны быть реализованы методы, переопределяющие абстрактные методы, унаследованные от класса `Shape`.
- Конструкторы подкласса `Triangle` должны содержать явные вызовы конструктора суперкласса `Shape`.
- Разработать отдельный Main-класс в пакете `ru.isu.math.graphics` с main-методом, в котором необходимо создать несколько объектов классов `Rectangle`, `Ellipse`, `Triangle` и нарисовать соответствующие им прямоугольники, эллипсы, треугольники в файле изображения формата PNG. 
- Сделать серию изображений с масштабированием, перемещением и вращением фигур (каждое изображения серии сохранить в отдельный файл формата PNG).
- Продемонстрировать работу отладчика в IDE. Установить точку останова в вашем коде. Запустить отладчик. Показать какие значения имеют локальные переменные в момент останова. Сделать один или несколько шагов так, продемонстрировать изменение значений локальных переменных при пошаговом выполнении кода. Установить курсор в некоторой строке вашего кода и выполнить код до этой строки; показать какие значения имеют локальные переменные в этот момент. Возобновить выполнение программы в обычном режиме.

**6-3** — 2 балла

- Разработать приложение с интерфейсом командной строки (CLI) для создания и управления простыми графическими фигурами (прямоугольники, эллипсы, треугольники) с возможностью экспорта результата в растровое изображение. 
- Программа должна поддерживать создание трех типов фигур: прямоугольники (`Rectangle`), эллипсы (`Ellipse`) и треугольники (`Triangle`).
- Программа должна позволять перемещать выбранной фигуры на заданное смещение по осям X и Y.
- Программа должна позволять вращать выбранную фигуру на заданный угол в градусах.
- Программа должна позволять увеличивать или уменьшать размер существующей фигуры в заданное количество раз.
- Программа должна сохранять все созданные фигуры в файл изображения в формате PNG.

Поддерживаемые команды:
- Создание фигур
	-   `create rectangle <x> <y> <width> <height>`
	-   `create ellipse <x> <y> <width> <height>`
	-   Пример: `create rectangle 50 50 100 200` — создает прямоугольник с вершиной в (50,50), шириной 100 и высотой 200.
	- После создания фигура получает уникальный числовой идентификатор (ID). Этот ID используется для управления фигурой в последующих командах.
- Перемещение фигур
	-   `move <id> <dx> <dy>`
	-   Пример: `move 1 10 -5` — перемещает фигуру с ID=1 на 10 пикселей вправо и на 5 пикселей вверх.
- Вращение фигур
	-   `rotate <id> <angle>`
	-   Пример: `rotate 1 90` — вращает фигуру с ID=1 на 90 градусов.
- Масштабирование фигур
	-   `scale <id> <factor>`
	-   Пример: `scale 1 1.5` — увеличивает фигуру с ID=1 в 1.5 раза.
	-   Пример: `scale 2 0.5` — уменьшает фигуру с ID=2 в 2 раза.
- Экспорт в изображение
	-   `export <filename.png>`
	-   Пример: `export my_drawing.png` — сохраняет изображение в файл `my_drawing.png` в текущей директории.
- Прочие команды
	-   `list` — выводит в консоль список всех фигур с их ID, типами и параметрами.
	-   `exit` — завершает работу приложения.

## Вопросы
1.	Как объявить абстрактный класс?
2.	Выделите в вашем коде абстрактные методы?
3.	Можно ли инстанцировать абстрактный класс?
4.	Какие подклассы есть в вашем коде?
5.	Какие суперклассы есть в вашем коде?
6.	Как в объявлении класса указывается, что он расширяет некоторый базовый класс?
7.	Выделите в вашем коде методы, которые переопределяют унаследованные методы.
8.	Используется ли вашем коде перегрузка методов?
9.	Используется ли вашем коде перегрузка конструкторов?
10.	Объясните какие поля и методы были унаследованы тем или иным производным классом от базового класса?
11.	Используется ли вашем коде расширение классов?
12.	Выделите вызовы конструкторов суперклассов?
13.	К каким полям и методам можно получить доступ через ключевое слово `super`?
14.	К каким полям и методам можно получить доступ через ключевое слово `this`?
15.	Используется ли вашем коде полиморфизм?
16.	Какой тип данных имеет то или иное поле?
17.	Какой тип данных имеет та или иная локальная переменная?
18.	Какие нестатические методы есть в вашем коде?
19.	Какие нестатические поля есть в вашем коде?
20.	Используется ли вашем коде переопределение методов?
21.	Выделите в вашем коде инструкции создания объектов ваших классов?
22.	Выделите в вашем коде вызовы конструкторов подклассов?
23.	Как инициализируется начальное состояние объектов вашего класса?
24.	Выделите в вашем коде вызовы методов экземпляров ваших классов?
25.	Объясните сигнатуру того или иного метода, объявленного в вашем классе?
26.	Какой возвращаемый тип данных имеет тот или иной метод?
27.	Какой тип данных имеет то или иное выражение в вашем коде?
28.	В каком пакете находятся ваши классы?
29.	Какие статические методы есть в вашем коде?
30.	Какие статические поля есть в вашем коде?

## Дополнительные ресурсы
