
# Занятие 6. Классы и объекты (II)

## Наследование классов

_Наследование классов_ — это отношение между двумя классами, в котором один класс (_подкласс_) расширяет другой класс (_суперкласс_) дополнительными полями и методами. 

 - _Суперкласс_ — это класс, от которого производится наследование (расширение).
 -  _Подкласс_ — это класс, который наследует (расширяет) общий класс.

Другие названия:
- _Суперкласс_ = *Базовый класс* = *Родительский класс* = *Предок*
- _Подкласс_ = *Производный класс* = *Дочерний класс* = *Потомок*

> Java допускает только одиночное наследование классов
 
Для того чтобы один класс наследовал другой, необходимо в его объявлении указать суперкласс после ключевого слова `extends`. 

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    String firstName, lastName;
    int age;
    
    // Методы экземпляра суперкласса
    String greeting() {
        return "Hello, my name " + firstName + " " + lastName;
    }
    
    // Конструкторы
}

// Подкласс
public class Student extends Person {
    // Переменные экземпляра подкласса
    String studentId;
    int[] scores; 
    
    // Методы экземпляра подкласса
    int averageScore() {
        int sum = 0;
        for (int score : scores)
            sum += score;
        return sum / scores.length;
    }
    
    // Конструкторы
}
```

Объекты подкласса обладают состоянием и поведением определенным совместно в суперклассе и подклассе.

```java
// Суперкласс
public class MainClass {
    public static void main(String[] args) {
        Person p;
        Student s;
        // Создание объектов классов Person и Student 
        // Инициализация переменных p и s
        
        System.out.println("Hello, I am a person");
        // Обращение к методу объекта суперкласса
        System.out.println(p.greeting); 

        System.out.println("Hello, I am a student");
        // Обращение к методам объекта подкласса 
        System.out.println(s.greeting); 
        System.out.printf("My average score is %d%n", s.averageScore());
    }
}
```

Доступные поля и методы суперкласса могут использоваться в подклассе как собственные.

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    String firstName, lastName;
    int age;
    
    // Конструкторы
}

// Подкласс
public class Student extends Person {
    // Переменные экземпляра подкласса
    String studentId;
    int[] scores; 
  
    // Методы экземпляра подкласса
    String info() {
        String template = "%s %s (ID: %s)%n";
        // Обращение к полям, объявленным в суперклассе
        return String.format(template, firstName, lastName, studentId);
    }
    
    // Конструкторы
}
```

## Ключевое слово `super`

### Скрытие полей при наследовании

Поле, объявленное в подклассе, может иметь тоже самое имя, что и поле, объявленное в суперклассе. При этом происходит скрытие такого поля, объявленного в суперклассе, одноименным полем, объявленным в подклассе.

```java
// Суперкласс
public class Person {
    // Переменная экземпляра суперкласса
    int title = "Mr.";
    
    // Другие поля и методы
}

// Подкласс
public class Student extends Person {    
    // Переменная экземпляра подкласса,
    // которая скрывает одноименное поле из суперкласса
    int title = "Student"; 
		
    void printInfo() {
        // Обращение к полю title, объявленному в подклассе
        System.out.println(title); // "Student"
        
        // Обращение к полю title, объявленному в суперклассе
        System.out.println(super.title); // "Mr."
    }

    // Другие поля и методы
}
```



### Вызов конструктора суперкласса 

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    String firstName, lastName;
    int age;
    
    // Конструктор в суперклассе
    Person(String firstName, String lastName, int age) {
        // Инициализация полей, объявленных в суперклассе
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
}

// Подкласс
public class Student extends Person {
    // Переменные и методы экземпляра подкласса
    String studentId;
    int[] scores; 
    
    // Конструктор в подклассе
    Student(String firstName, String lastName, int age, String studentId) {
        // Обязательный вызов конструктора суперкласса
        super(firstName, lastName, age);
        // Инициализация полей, объявленных в подклассе
        this.studentId;
        scores = new int[10];
    }    
}
```

Вызов конструктора безаргументного конструктора суперкласса по умолчанию

```java
// Суперкласс
public class Person {
    // Переменные экземпляра суперкласса
    String firstName, lastName;
    int age;
    
    // Безаргументный конструктор
    Person() {
    }
}

// Подкласс
public class Student extends Person {
    // Переменные и методы экземпляра подкласса
    String studentId;
    int[] scores; 
    
    // Конструктор в подклассе
    Student(String firstName, String lastName, int age, String studentId) {
        // Компилятор добавит вызов безаргументного конструктора
        // super();
        // Инициализация полей, объявленных в суперклассе
        super.firstName = firstName;
        super.lastName = lastName;
        super.age = age;
        // Инициализация полей, объявленных в подклассе
        this.studentId;
        scores = new int[10];
    }    
}
```

## Переопределение методов

*Переопределение методов* — это механизм, позволяющий подклассу предоставить свою собственную реализацию нестатического метода, который уже определен в суперклассе.

**Основные правила переопределения методов:**
 - Сигнатура метода (имя, параметры, возвращаемый тип) в подклассе должна быть идентичной сигнатуре метода в суперклассе. 
 - Модификатор доступа метода в подклассе не может быть более строгим, чем у метода в суперклассе. 
 - Ключевое слово `final` в объявлении метода запрещает его переопределение.

```java
public class Shape {
    // Координаты левого верхнего угла
    int x, y;
    
    // Определение нестатического метода в суперклассе
    String info() {
        return String.format("Shape at (%d, %d)", x, y);
    }
    
    // Другие поля и методы
    // Конструкторы
}

class Rectangle extends Shape {
    // Переопреденение метода в подклассе
    String info() {
		    // Другая реализация
        return String.format("Rectangle at (%d, %d)", x, y);
    }
}
```

## Абстрактные классы

Абстрактный метод не имеет реализации; объявляется с ключевым словом `abstract`. Если в классе объявлен абстрактный метод, то и сам класс должен быть объявлен как абстрактный с помощью ключевого слова `abstract`. Абстрактный класс не может иметь объектов; представляет абстрактные сущности.
```java
import java.awt.*;

// Абстрактный класс

public abstract class Shape {
    // Координаты базовой точки
    int x, y;
    // Цвет
    Color color;

    // Конструктор
    Shape(int x, int y, Color color) {
        this.x = x;
        this.y = y;
        this.color = color;
    }

    // Переместить фигуру
    void move(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // Абстрактные методы

    // Вычислить площадь фигуры
    abstract int area();
    
    // Нарисовать фигуру в графическом контексте
    abstract void draw(Graphics2D g);
}
```

### Наследование абстрактных классов

_Наследования классов_ — отношение между двумя классами, в котором один специализированный класс (_подкласс_) расширяет другой общий класс (_суперкласс_) дополнительными полями и методами.

_Суперкласс_ — общий класс, от которого производится наследование (расширение).

_Подкласс_ — специализированный класс, который наследует (расширяет) общий класс.

Объекты подкласса обладают состоянием и поведением определенным совместно суперклассом и подклассом.

Для того чтобы один класс наследовал другой, необходимо в его объявлении указать суперкласс после ключевого слова `extends`. Доступные поля и методы суперкласса могут использоваться в подклассе как собственные.
```java
import java.awt.*;

public class Rectangle extends Shape {
    // Поля
    int width, height;

    // Конструктор
    Rectangle(int x, int y, int width, int height, Color color) {
        super(x, y, color); // Обязательный вызов конструктора суперкласса
        this.width = width;
        this.height = height;
    }

    // Переопределение абстрактных методов

    // Вычислить площадь
    int area() {
        return width * height;
    }

    // Нарисовать прямоугольник в графическом контексте
    void draw(Graphics2D g) {
        g.setColor(color);
        g.fillRect(x, y, width, height);
    }
}
```

## Полиморфизм

_Полиморфизм_ — «один интерфейс, множество реализаций».

Полиморфизм связан с наследованием, т.к. наследование позволяет переопределять методы. Например, создадим суперкласс `Shape` с методом `draw`.
```java
public abstract class Shape {
    int x, y;
    Color color;

    // ... методы и конструкторы

    // Нарисовать фигуру в графическом контексте
    abstract void draw(Graphics2D g);
}
```

Данный метод будет переопределен в каждом подклассе: `Line`, `Rectangle`, `Ellipse`.

Подкласс `Line` расширяет суперкласс `Shape`
```java
public class Line extends Shape {
    int x1, y1, x2, y2;

    // ... методы и конструкторы

    // Переопределение метода
    void draw(Graphics2D g) {
        g.setColor(color);
        g.drawLine(x1,y1,x2,y2);
    }
}
```

Подкласс `Rectangle` расширяет суперкласс `Shape`
```java
public class Rectangle extends Shape implements Scalable {
    // Поля
    private int width, height;

    // ... методы и конструкторы

    // Переопределение метода
    public void draw(Graphics2D g) {
        g.setColor(color);
        g.fillRect(x, y, width, height);
    }
}
```

Подкласс `Ellipse` расширяет суперкласс `Shape`
```java
public class Ellipse extends Rectangle {
    // ... методы и конструкторы

    // Переопределение метода
    public void draw(Graphics2D g) {
        g.setColor(color);
        g.drawOval(x, y, width, height);
    }
}
```

Таким образом метод «draw», объявленный в суперклассе, является единым интерфейсом. При этом каждый подкласс предоставляет собственную реализацию этого метода. Создадим объекты этих подклассов, наследование позволяет объявлять их с типом данных, определенным суперклассом. Однако поведение объектов определяется их классами. Поэтому отрисовка созданных графических фигур на графическом контексте выполняется корректно.
```java
// Создать линию
Shape line = new Line(100,200, 300, 300, Color.RED);

// Создать прямоугольник
Shape rect = new Rectangle(0, 0, 50, 100, Color.GRAY);

// Создать эллипс
Shape ellipse = new Ellipse(100, 100, 100, 100, Color.GREEN);

// Создать массив графических фигур
Shape shapes[] = {line, rect, ellipse};

// Нарисовать все графические фигуры 
for (Shape shape: shapes)
    shape.draw(g);
```
## Статические поля и методы

**Разница статического и нестатического контекста:**
 - Нестатические поля и методы относятся к экземплярам класса.
 - Статические поля и методы относятся к самому классу.
 - Статические члены объявляются с ключевым словом `static`.

Статические поля, в том числе, используются для определения глобальных констант.

```java
public class Shape {
    // Статические поля (глобальные константы)
		
    // Минимальные значения координат левого верхнего угла
    public static final int MIN_X = 0; 
    public static final int MIN_Y = 0;

    // Минимальные значения координат левого верхнего угла
    public static final int MAX_X = 1000; 
    public static final int MAX_Y = 1000;

    // Минимальные значения ширины и высоты
    public static final int MIN_WIDTH = 1; 
    public static final int MIN_HEIGHT = 1;
    
    // Максимальные значения ширины и высоты
    public static final int MAX_WIDTH = 1000; 
    public static final int MAX_HEIGHT = 1000;

    // Нестатические поля 

    // Координаты верхнего левого угла органичивающей рамки
    int width = MIN_WIDTH, 
    int height = MIN_HEIGHT;
    
    // Ширина и высота органичивающей рамки
    private int width = MIN_WIDTH, 
    private int height = MIN_HEIGHT;

    // Методы доступа к нестатическим полям
    public int getX() {
        return x;
    }
    
    public void setX(int x) {
		    // Проверка допустимости значения x-координаты
        if (x >= MIN_X && x <= MAX_X)
            this.x = x;
    }

    public int getY() {
        return y;
    }
    
    public void setY(int y) {
        // Проверка допустимости значения y-координаты
        if (y >= MIN_Y && y <= MAX_Y)
            this.y = y;
    }

    public int getWidth() {
        return width;
    }
    
    public void setWidth(int width) {
        // Проверка допустимости значения ширины
        if (width >= MIN_WIDTH && width <= MAX_WIDTH)
            this.width = width;
    }
    
    public int getHeight() {
        return height;
    }
    
    public void setHeight(int height) {
        // Проверка допустимости значения высоты
        if (height >= MIN_HEIGHT && height <= MAX_HEIGHT)
            this.height = height;
    }

    // Конструктор
    public Shape(int x, int y, int width, int height) {
        setX(x);
        setY(y);
        setWidth(width);
        setHeight(height);
    }
    
    // Другие методы
}
```

Статические методы имеют доступ только к другим статическим полям и методам.

```java
public class Rectangle extends Shape {
    // Конструктор
    public Rectangle(int x, int y, int width, int height) {
        super(x, y, width, height);
    }

    // Статические методы

    // Скопировать заданный прямоугольник
    public static Rectangle copy(Rectangle rect) {
        return new Rectangle(rect.getX(), rect.getY(),
                rect.getWidth(), rect.getHeight());
    }

    // Создать эллипс вписанный в заданный прямоугольник
    public static Ellipse asEllipse(Rectangle rect) {
        return new Ellipse(rect.getX(), rect.getY(),
                rect.getX(), rect.getY());
    }

    // Другие методы
}
```

Открытые статические поля и методы доступны без создания объектов. Вызвать статические методы вне класса, в котором они объявлены, можно через имя класса.

```java
public class MainClass {
    public static void main(String[] args) {
        // Создать прямоугольник
        Rectangle rect = new Rectangle(0,0, 50, 100);
        
        // Создать эллипс, вызвав статический метод
        Ellipse ellipse = Rectangle.asEllipse(rect);
    }
}
```

## Завершенные классы

*Завершенные классы* — это классы, которые нельзя наследовать.

```java
// Завершенный класс - нельзя наследовать
final class MathConstants {
    // Глобальные константы
    public static final double PI = 3.14159;
    public static final double E = 2.71828;
    
    // Статический метод
    public static double circleArea(double radius) {
        return PI * radius * radius;
    }
}

// Попытка наследования вызовет ошибку компиляции:
// class ExtendedMath extends MathConstants { } // ОШИБКА!

public class MainClass {
    public static void main(String[] args) {
        System.out.println("PI = " + MathConstants.PI);
        System.out.println("Площадь круга: " + MathConstants.circleArea(5.0));
    }
}
```

## Завершенные методы

*Завершенные методы* — это нестатические методы, которые нельзя переопределять.
```java
public class Shape {
    // Координаты левого верхнего угла
    int x, y;
    
    // Другие поля и метода
		
    // Завершенный метод
    final void move(int dx, int dy) {
        x += dx;
        y += dy; 
    }
}

public class Rectangle extends Shape {
	// Попытка переопределения вызовет ошибку компиляции:
	// void move(int dx, int dy) {} // ОШИБКА!
		
    // Другие поля и метода		
}
```

## Задания

**6-1** — 1 балл

- Разработать абстрактный класс `Shape` в пакете `ru.isu.math.graphics` для представления графических фигур.
- В классе `Shape` должны быть объявлены нестатические поля (координаты левого верхнего угла ограничивающей рамки, ширина и высота ограничивающей рамки, цвет контура, цвет заливки, угол поворота).
- В классе `Shape` должны объявлены завершенные статические поля: допустимые (минимальные и максимальные) значения координат левого верхнего угла ограничивающей рамки, ширины и высоты ограничивающей рамки, угла поворота.
- В классе `Shape` должно контролироваться присваивание значений нестатическим полям, а именно значения координат левого верхнего угла ограничивающей рамки, ширины и высоты ограничивающей рамки, угла поворота должны принадлежать диапазонам допустимых значений, определенных соответствующими глобальными константами. 
- В классе `Shape` должны быть объявлены нестатические завершенные методы (перемещения, вращения, масштабирования).
-  В классе `Shape` должны быть объявлены абстрактные методы (вычисления площади, отрисовки на графическом контексте) 
- В классе `Shape` должны быть конструкторы с аргументами.
- Разработать класс `Rectangle` в пакете `ru.isu.math.graphics` для представления прямоугольников: класс должен быть унаследован от класса «Shape».
- В классе `Rectangle` должны быть объявлены и реализованы методы, переопределяющие абстрактные методы, унаследованные от класса `Shape`.
- Конструкторы подкласса `Rectangle` должны содержать явные вызовы конструктора суперкласса `Shape`.
- Разработать отдельный Main-класс в пакете  `ru.isu.math.graphics`  с main-методом, в котором необходимо создать несколько объектов класса  `Rectangle`  с помощью доступных конструкторов и через доступное поведение (перемещение, поворот, масштабирование) объектов класса  `Rectangle`  изменить их состояние. Вычислить площади созданных прямоугольников.
- Продемонстрировать работу отладчика в IDE. Установить точку останова в вашем коде. Запустить отладчик. Показать какие значения имеют локальные переменные в момент останова. Сделать один или несколько шагов так, продемонстрировать изменение значений локальных переменных при пошаговом выполнении кода. Установить курсор в некоторой строке вашего кода и выполнить код до этой строки; показать какие значения имеют локальные переменные в этот момент. Возобновить выполнение программы в обычном режиме.

**6-2** — 1 балл

- Разработать класс `Ellipse` в пакете `ru.isu.math.graphics` для представления эллипсов: класс должен быть унаследован от класса `Shape`.
- В классе `Ellipse` должны быть реализованы методы, переопределяющие абстрактные методы, унаследованные от класса `Shape`.
- Конструкторы подкласса `Ellipse` должны содержать явные вызовы конструктора суперкласса `Shape`.
- Разработать класс `Triangle` для представления треугольников: класс должен быть унаследован от класса `Shape`; в классе должно быть переопределение абстрактных методов из класса `Shape`.
- В классе `Triangle` должны быть реализованы методы, переопределяющие абстрактные методы, унаследованные от класса `Shape`.
- Конструкторы подкласса `Triangle` должны содержать явные вызовы конструктора суперкласса `Shape`.
- Разработать отдельный Main-класс в пакете `ru.isu.math.graphics` с main-методом, в котором необходимо создать несколько объектов классов `Rectangle`, `Ellipse`, `Triangle` и нарисовать соответствующие им прямоугольники, эллипсы, треугольники в файле изображения формата PNG. 
- Добавить в класс `Rectangle` статический метод для конвертирования прямоугольников в эллипсы.
- Добавить в класс `Ellipse` статический метод для конвертирования эллипсов в прямоугольники.
- Разработать отдельный Main-класс в пакете  `ru.isu.math.graphics`  с main-методом, в котором необходимо создать несколько объектов класса  `Rectangle`, объектов класса  `Ellipse`  и объектов класса  `Triangle`. Добавить созданные объекты в массив типа `Shape[]`. Перебрав данный массив, нарисовать соответствующие им прямоугольники, эллипсы и треугольники в файле изображения формата PNG; при этом сделать серию изображений с масштабированием, перемещением и вращением фигур (каждое изображения серии сохранить в отдельный файл формата PNG).

**6-3** — 2 балла

- Разработать приложение с интерфейсом командной строки (CLI) для создания и управления простыми графическими фигурами (прямоугольники, эллипсы, треугольники) с возможностью экспорта результата в растровое изображение. 
- Программа должна поддерживать создание трех типов фигур: прямоугольники, эллипсы и треугольники. (Фигуры должны быть представлены объектами соответственно классов `Rectangle`, `Ellipse` и  `Triangle`, описанных в двух предыдущих заданиях.)
- Программа должна позволять перемещать выбранной фигуры на заданное смещение по осям X и Y.
- Программа должна позволять вращать выбранную фигуру на заданный угол в градусах.
- Программа должна позволять увеличивать или уменьшать размер существующей фигуры в заданное количество раз.
- Программа должна сохранять все созданные фигуры в файл изображения в формате PNG.
- Сопроводить исходный код Javadoc-комментариями и сгенерировать HTML-документацию с помощью команды javadoc.
- Собрать проект в виде запускаемого JAR-файла и продемонстрировать его работу.

Поддерживаемые команды:
- Создание фигур
	-   `create rectangle <x> <y> <width> <height>`
	-   `create ellipse <x> <y> <width> <height>`
	-   Пример: `create rectangle 50 50 100 200` — создает прямоугольник с вершиной в (50, 50), шириной 100 и высотой 200.
	- После создания фигура получает уникальный числовой идентификатор (ID). Этот ID используется для управления фигурой в последующих командах.
- Перемещение фигур
	-   `move <id> <dx> <dy>`
	-   Пример: `move 1 10 -5` — перемещает фигуру с ID=1 на 10 пикселей вправо и на 5 пикселей вверх.
- Вращение фигур
	-   `rotate <id> <angle>`
	-   Пример: `rotate 1 90` — вращает фигуру с ID=1 на 90 градусов.
- Масштабирование фигур
	-   `scale <id> <factor>`
	-   Пример: `scale 1 1.5` — увеличивает фигуру с ID=1 в 1.5 раза.
	-   Пример: `scale 2 0.5` — уменьшает фигуру с ID=2 в 2 раза.
- Экспорт в изображение
	-   `export <filename.png>`
	-   Пример: `export my_drawing.png` — сохраняет изображение в файл `my_drawing.png` в текущей директории.
- Прочие команды
	-   `list` — выводит в консоль список всех фигур с их ID, типами и параметрами.
	-   `exit` — завершает работу приложения.

## Вопросы
1.	Как объявить абстрактный класс?
2.	Выделите в вашем коде абстрактные методы?
3.	Можно ли инстанцировать абстрактный класс?
4.	Какие подклассы есть в вашем коде?
5.	Какие суперклассы есть в вашем коде?
6.	Как в объявлении класса указывается, что он расширяет некоторый базовый класс?
7.	Выделите в вашем коде методы, которые переопределяют унаследованные методы.
8.	Используется ли вашем коде перегрузка методов?
9.	Используется ли вашем коде перегрузка конструкторов?
10.	Объясните какие поля и методы были унаследованы тем или иным производным классом от базового класса?
11.	Используется ли вашем коде расширение классов?
12.	Выделите вызовы конструкторов суперклассов?
13.	К каким полям и методам можно получить доступ через ключевое слово `super`?
14.	К каким полям и методам можно получить доступ через ключевое слово `this`?
15.	Используется ли вашем коде полиморфизм?
16.	Какой тип данных имеет то или иное поле?
17.	Какой тип данных имеет та или иная локальная переменная?
18.	Какие нестатические методы есть в вашем коде?
19.	Какие нестатические поля есть в вашем коде?
20.	Используется ли вашем коде переопределение методов?
21.	Выделите в вашем коде инструкции создания объектов ваших классов?
22.	Выделите в вашем коде вызовы конструкторов подклассов?
23.	Как инициализируется начальное состояние объектов вашего класса?
24.	Выделите в вашем коде вызовы методов экземпляров ваших классов?
25.	Объясните сигнатуру того или иного метода, объявленного в вашем классе?
26.	Какой возвращаемый тип данных имеет тот или иной метод?
27.	Какой тип данных имеет то или иное выражение в вашем коде?
28.	В каком пакете находятся ваши классы?
29.	Какие статические методы есть в вашем коде?
30.	Какие статические поля есть в вашем коде?

## Дополнительные ресурсы
